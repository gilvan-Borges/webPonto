{
  "version": 3,
  "sources": ["../../../../../../node_modules/ol/ImageState.js", "../../../../../../node_modules/ol/size.js", "../../../../../../node_modules/ol/Image.js"],
  "sourcesContent": ["/**\r\n * @module ol/ImageState\r\n */\n\n/**\r\n * @enum {number}\r\n */\nexport default {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  ERROR: 3,\n  EMPTY: 4\n};", "/**\r\n * @module ol/size\r\n */\n\n/**\r\n * An array of numbers representing a size: `[width, height]`.\r\n * @typedef {Array<number>} Size\r\n * @api\r\n */\n\n/**\r\n * Returns a buffered size.\r\n * @param {Size} size Size.\r\n * @param {number} num The amount by which to buffer.\r\n * @param {Size} [dest] Optional reusable size array.\r\n * @return {Size} The buffered size.\r\n */\nexport function buffer(size, num, dest) {\n  if (dest === undefined) {\n    dest = [0, 0];\n  }\n  dest[0] = size[0] + 2 * num;\n  dest[1] = size[1] + 2 * num;\n  return dest;\n}\n\n/**\r\n * Determines if a size has a positive area.\r\n * @param {Size} size The size to test.\r\n * @return {boolean} The size has a positive area.\r\n */\nexport function hasArea(size) {\n  return size[0] > 0 && size[1] > 0;\n}\n\n/**\r\n * Returns a size scaled by a ratio. The result will be an array of integers.\r\n * @param {Size} size Size.\r\n * @param {number} ratio Ratio.\r\n * @param {Size} [dest] Optional reusable size array.\r\n * @return {Size} The scaled size.\r\n */\nexport function scale(size, ratio, dest) {\n  if (dest === undefined) {\n    dest = [0, 0];\n  }\n  dest[0] = size[0] * ratio + 0.5 | 0;\n  dest[1] = size[1] * ratio + 0.5 | 0;\n  return dest;\n}\n\n/**\r\n * Returns an `Size` array for the passed in number (meaning: square) or\r\n * `Size` array.\r\n * (meaning: non-square),\r\n * @param {number|Size} size Width and height.\r\n * @param {Size} [dest] Optional reusable size array.\r\n * @return {Size} Size.\r\n * @api\r\n */\nexport function toSize(size, dest) {\n  if (Array.isArray(size)) {\n    return size;\n  }\n  if (dest === undefined) {\n    dest = [size, size];\n  } else {\n    dest[0] = size;\n    dest[1] = size;\n  }\n  return dest;\n}", "/**\r\n * @module ol/Image\r\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport ImageState from './ImageState.js';\nimport { CREATE_IMAGE_BITMAP, IMAGE_DECODE } from './has.js';\nimport { listenOnce, unlistenByKey } from './events.js';\nimport { toPromise } from './functions.js';\n\n/**\r\n * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a\r\n * `{string}` for the src as arguments. It is supposed to make it so the\r\n * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the\r\n * content specified by the src. If not specified, the default is\r\n *\r\n *     function(image, src) {\r\n *       image.getImage().src = src;\r\n *     }\r\n *\r\n * Providing a custom `imageLoadFunction` can be useful to load images with\r\n * post requests or - in general - through XHR requests, where the src of the\r\n * image element would be set to a data URI when the content is loaded.\r\n *\r\n * @typedef {function(import(\"./Image.js\").default, string): void} LoadFunction\r\n * @api\r\n */\n\n/**\r\n * @typedef {Object} ImageObject\r\n * @property {import(\"./extent.js\").Extent} [extent] Extent, if different from the requested one.\r\n * @property {import(\"./resolution.js\").ResolutionLike} [resolution] Resolution, if different from the requested one.\r\n * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).\r\n * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.\r\n * @property {import('./DataTile.js').ImageLike} image Image.\r\n */\n\n/**\r\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\r\n * For images that cover any extent and resolution (static images), the loader function should not accept\r\n * any arguments. The function returns an {@link import(\"./DataTile.js\").ImageLike image}, an\r\n * {@link import(\"./Image.js\").ImageObject image object}, or a promise for the same.\r\n * For loaders that generate images, the promise should not resolve until the image is loaded.\r\n * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,\r\n * it has to return an {@link import(\"./Image.js\").ImageObject image object} with the `image` and the\r\n * correct `extent`, `resolution` and `pixelRatio`.\r\n *\r\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} Loader\r\n * @api\r\n */\n\n/**\r\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\r\n * The function returns a promise for an  {@link import(\"./Image.js\").ImageObject image object}.\r\n *\r\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} ImageObjectPromiseLoader\r\n */\n\nclass ImageWrapper extends EventTarget {\n  /**\r\n   * @param {import(\"./extent.js\").Extent} extent Extent.\r\n   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y\r\n   * resolution will be assumed.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"./ImageState.js\").default|import(\"./Image.js\").Loader} stateOrLoader State.\r\n   */\n  constructor(extent, resolution, pixelRatio, stateOrLoader) {\n    super();\n\n    /**\r\n     * @protected\r\n     * @type {import(\"./extent.js\").Extent}\r\n     */\n    this.extent = extent;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\r\n     * @protected\r\n     * @type {number|Array<number>|undefined}\r\n     */\n    this.resolution = resolution;\n\n    /**\r\n     * @protected\r\n     * @type {import(\"./ImageState.js\").default}\r\n     */\n    this.state = typeof stateOrLoader === 'function' ? ImageState.IDLE : stateOrLoader;\n\n    /**\r\n     * @private\r\n     * @type {import('./DataTile.js').ImageLike|null}\r\n     */\n    this.image_ = null;\n\n    /**\r\n     * @protected\r\n     * @type {import(\"./Image.js\").Loader}\r\n     */\n    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;\n  }\n\n  /**\r\n   * @protected\r\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\r\n   * @return {import(\"./extent.js\").Extent} Extent.\r\n   */\n  getExtent() {\n    return this.extent;\n  }\n\n  /**\r\n   * @return {import('./DataTile.js').ImageLike} Image.\r\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\r\n   * @return {number} PixelRatio.\r\n   */\n  getPixelRatio() {\n    return this.pixelRatio_;\n  }\n\n  /**\r\n   * @return {number|Array<number>} Resolution.\r\n   */\n  getResolution() {\n    return /** @type {number} */this.resolution;\n  }\n\n  /**\r\n   * @return {import(\"./ImageState.js\").default} State.\r\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\r\n   * Load not yet loaded URI.\r\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      if (this.loader) {\n        this.state = ImageState.LOADING;\n        this.changed();\n        const resolution = this.getResolution();\n        const requestResolution = Array.isArray(resolution) ? resolution[0] : resolution;\n        toPromise(() => this.loader(this.getExtent(), requestResolution, this.getPixelRatio())).then(image => {\n          if ('image' in image) {\n            this.image_ = image.image;\n          }\n          if ('extent' in image) {\n            this.extent = image.extent;\n          }\n          if ('resolution' in image) {\n            this.resolution = image.resolution;\n          }\n          if ('pixelRatio' in image) {\n            this.pixelRatio_ = image.pixelRatio;\n          }\n          if (image instanceof HTMLImageElement || image instanceof ImageBitmap || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement) {\n            this.image_ = image;\n          }\n          this.state = ImageState.LOADED;\n        }).catch(error => {\n          this.state = ImageState.ERROR;\n          console.error(error); // eslint-disable-line no-console\n        }).finally(() => this.changed());\n      }\n    }\n  }\n\n  /**\r\n   * @param {import('./DataTile.js').ImageLike} image The image.\r\n   */\n  setImage(image) {\n    this.image_ = image;\n  }\n\n  /**\r\n   * @param {number|Array<number>} resolution Resolution.\r\n   */\n  setResolution(resolution) {\n    this.resolution = resolution;\n  }\n}\n\n/**\r\n * @param {import('./DataTile.js').ImageLike} image Image element.\r\n * @param {function():any} loadHandler Load callback function.\r\n * @param {function():any} errorHandler Error callback function.\r\n * @return {function():void} Callback to stop listening.\r\n */\nexport function listenImage(image, loadHandler, errorHandler) {\n  const img = /** @type {HTMLImageElement} */image;\n  let listening = true;\n  let decoding = false;\n  let loaded = false;\n  const listenerKeys = [listenOnce(img, EventType.LOAD, function () {\n    loaded = true;\n    if (!decoding) {\n      loadHandler();\n    }\n  })];\n  if (img.src && IMAGE_DECODE) {\n    decoding = true;\n    img.decode().then(function () {\n      if (listening) {\n        loadHandler();\n      }\n    }).catch(function (error) {\n      if (listening) {\n        if (loaded) {\n          loadHandler();\n        } else {\n          errorHandler();\n        }\n      }\n    });\n  } else {\n    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));\n  }\n  return function unlisten() {\n    listening = false;\n    listenerKeys.forEach(unlistenByKey);\n  };\n}\n\n/**\r\n * Loads an image.\r\n * @param {HTMLImageElement} image Image, not yet loaded.\r\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\r\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\r\n * @api\r\n */\nexport function load(image, src) {\n  return new Promise((resolve, reject) => {\n    function handleLoad() {\n      unlisten();\n      resolve(image);\n    }\n    function handleError() {\n      unlisten();\n      reject(new Error('Image load error'));\n    }\n    function unlisten() {\n      image.removeEventListener('load', handleLoad);\n      image.removeEventListener('error', handleError);\n    }\n    image.addEventListener('load', handleLoad);\n    image.addEventListener('error', handleError);\n    if (src) {\n      image.src = src;\n    }\n  });\n}\n\n/**\r\n * @param {HTMLImageElement} image Image, not yet loaded.\r\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\r\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\r\n */\nexport function decodeFallback(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return image.src && IMAGE_DECODE ? new Promise((resolve, reject) => image.decode().then(() => resolve(image)).catch(e => image.complete && image.width ? resolve(image) : reject(e))) : load(image);\n}\n\n/**\r\n * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns\r\n * the loaded image otherwise.\r\n * @param {HTMLImageElement} image Image, not yet loaded.\r\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\r\n * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an\r\n * `HTMLImageElement` if `createImageBitmap()` is not supported.\r\n * @api\r\n */\nexport function decode(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return image.src && IMAGE_DECODE && CREATE_IMAGE_BITMAP ? image.decode().then(() => createImageBitmap(image)).catch(e => {\n    if (image.complete && image.width) {\n      return image;\n    }\n    throw e;\n  }) : decodeFallback(image);\n}\nexport default ImageWrapper;"],
  "mappings": ";;;;;;;;;;AAOA,IAAO,qBAAQ;AAAA,EACb,MAAM;AAAA,EACN,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,OAAO;AACT;;;ACkBO,SAAS,QAAQ,MAAM;AAC5B,SAAO,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI;AAClC;AASO,SAAS,MAAM,MAAM,OAAO,MAAM;AACvC,MAAI,SAAS,QAAW;AACtB,WAAO,CAAC,GAAG,CAAC;AAAA,EACd;AACA,OAAK,CAAC,IAAI,KAAK,CAAC,IAAI,QAAQ,MAAM;AAClC,OAAK,CAAC,IAAI,KAAK,CAAC,IAAI,QAAQ,MAAM;AAClC,SAAO;AACT;AAWO,SAAS,OAAO,MAAM,MAAM;AACjC,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,WAAO;AAAA,EACT;AACA,MAAI,SAAS,QAAW;AACtB,WAAO,CAAC,MAAM,IAAI;AAAA,EACpB,OAAO;AACL,SAAK,CAAC,IAAI;AACV,SAAK,CAAC,IAAI;AAAA,EACZ;AACA,SAAO;AACT;;;ACqIO,SAAS,YAAY,OAAO,aAAa,cAAc;AAC5D,QAAM;AAAA;AAAA,IAAqC;AAAA;AAC3C,MAAI,YAAY;AAChB,MAAI,WAAW;AACf,MAAI,SAAS;AACb,QAAM,eAAe,CAAC,WAAW,KAAK,kBAAU,MAAM,WAAY;AAChE,aAAS;AACT,QAAI,CAAC,UAAU;AACb,kBAAY;AAAA,IACd;AAAA,EACF,CAAC,CAAC;AACF,MAAI,IAAI,OAAO,cAAc;AAC3B,eAAW;AACX,QAAI,OAAO,EAAE,KAAK,WAAY;AAC5B,UAAI,WAAW;AACb,oBAAY;AAAA,MACd;AAAA,IACF,CAAC,EAAE,MAAM,SAAU,OAAO;AACxB,UAAI,WAAW;AACb,YAAI,QAAQ;AACV,sBAAY;AAAA,QACd,OAAO;AACL,uBAAa;AAAA,QACf;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH,OAAO;AACL,iBAAa,KAAK,WAAW,KAAK,kBAAU,OAAO,YAAY,CAAC;AAAA,EAClE;AACA,SAAO,SAAS,WAAW;AACzB,gBAAY;AACZ,iBAAa,QAAQ,aAAa;AAAA,EACpC;AACF;AASO,SAAS,KAAK,OAAO,KAAK;AAC/B,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,aAAS,aAAa;AACpB,eAAS;AACT,cAAQ,KAAK;AAAA,IACf;AACA,aAAS,cAAc;AACrB,eAAS;AACT,aAAO,IAAI,MAAM,kBAAkB,CAAC;AAAA,IACtC;AACA,aAAS,WAAW;AAClB,YAAM,oBAAoB,QAAQ,UAAU;AAC5C,YAAM,oBAAoB,SAAS,WAAW;AAAA,IAChD;AACA,UAAM,iBAAiB,QAAQ,UAAU;AACzC,UAAM,iBAAiB,SAAS,WAAW;AAC3C,QAAI,KAAK;AACP,YAAM,MAAM;AAAA,IACd;AAAA,EACF,CAAC;AACH;AAOO,SAAS,eAAe,OAAO,KAAK;AACzC,MAAI,KAAK;AACP,UAAM,MAAM;AAAA,EACd;AACA,SAAO,MAAM,OAAO,eAAe,IAAI,QAAQ,CAAC,SAAS,WAAW,MAAM,OAAO,EAAE,KAAK,MAAM,QAAQ,KAAK,CAAC,EAAE,MAAM,OAAK,MAAM,YAAY,MAAM,QAAQ,QAAQ,KAAK,IAAI,OAAO,CAAC,CAAC,CAAC,IAAI,KAAK,KAAK;AACpM;",
  "names": []
}
