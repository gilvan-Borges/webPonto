{
  "version": 3,
  "sources": ["../../../../../../node_modules/ol/layer/TileProperty.js", "../../../../../../node_modules/ol/layer/BaseTile.js", "../../../../../../node_modules/ol/renderer/Layer.js", "../../../../../../node_modules/ol/render/canvas/ZIndexContext.js", "../../../../../../node_modules/ol/renderer/canvas/Layer.js", "../../../../../../node_modules/ol/DataTile.js", "../../../../../../node_modules/ol/structs/LRUCache.js", "../../../../../../node_modules/ol/vec/mat4.js", "../../../../../../node_modules/ol/webgl/Canvas.js", "../../../../../../node_modules/ol/reproj/glreproj.js", "../../../../../../node_modules/ol/reproj/DataTile.js", "../../../../../../node_modules/ol/renderer/canvas/TileLayer.js", "../../../../../../node_modules/ol/layer/Tile.js"],
  "sourcesContent": ["/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'\n};", "/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const baseOptions = Object.assign({}, options);\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);\n  }\n\n  /**\n   * @return {number|undefined} The suggested cache size\n   * @protected\n   */\n  getCacheSize() {\n    return this.cacheSize_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */this.get(TileProperty.PRELOAD);\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR);\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\nexport default BaseTileLayer;", "/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport { abstract } from '../util.js';\nconst maxStaleKeys = 5;\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.staleKeys_ = new Array();\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.maxStaleKeys = maxStaleKeys;\n  }\n\n  /**\n   * @return {Array<string>} Get the list of stale keys.\n   */\n  getStaleKeys() {\n    return this.staleKeys_;\n  }\n\n  /**\n   * @param {string} key The new stale key.\n   */\n  prependStaleKey(key) {\n    this.staleKeys_.unshift(key);\n    if (this.staleKeys_.length > this.maxStaleKeys) {\n      this.staleKeys_.length = this.maxStaleKeys;\n    }\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */event.target;\n    if (image.getState() === ImageState.LOADED || image.getState() === ImageState.ERROR) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../Image.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferred(frameState) {}\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\nexport default LayerRenderer;", "/**\n * @module ol/render/canvas/ZIndexContext\n */\n\nimport { getSharedCanvasContext2D } from '../../dom.js';\n\n/** @typedef {CanvasRenderingContext2D & {globalAlpha: any}} ZIndexContextProxy */\n\n/**\n * @extends {CanvasRenderingContext2D}\n */\nclass ZIndexContext {\n  constructor() {\n    /**\n     * @private\n     * @type {Array<Array<*>>}\n     */\n    this.instructions_ = [];\n    /**\n     * @type {number}\n     */\n    this.zIndex = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.offset_ = 0;\n\n    /**\n     * @private\n     * @type {ZIndexContextProxy}\n     */\n    this.context_ = /** @type {ZIndexContextProxy} */\n    new Proxy(getSharedCanvasContext2D(), {\n      get: (target, property) => {\n        if (typeof (/** @type {*} */getSharedCanvasContext2D()[property]) !== 'function') {\n          // we only accept calling functions on the proxy, not accessing properties\n          return undefined;\n        }\n        if (!this.instructions_[this.zIndex + this.offset_]) {\n          this.instructions_[this.zIndex + this.offset_] = [];\n        }\n        this.instructions_[this.zIndex + this.offset_].push(property);\n        return this.pushMethodArgs_;\n      },\n      set: (target, property, value) => {\n        if (!this.instructions_[this.zIndex + this.offset_]) {\n          this.instructions_[this.zIndex + this.offset_] = [];\n        }\n        this.instructions_[this.zIndex + this.offset_].push(property, value);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * @private\n   * @param {...*} args Args.\n   * @return {ZIndexContext} This.\n   */\n  pushMethodArgs_ = (...args) => {\n    this.instructions_[this.zIndex + this.offset_].push(args);\n    return this;\n  };\n\n  /**\n   * Push a function that renders to the context directly.\n   * @param {function(CanvasRenderingContext2D): void} render Function.\n   */\n  pushFunction(render) {\n    this.instructions_[this.zIndex + this.offset_].push(render);\n  }\n\n  /**\n   * Get a proxy for CanvasRenderingContext2D which does not support getting state\n   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a\n   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,\n   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.\n   * @return {ZIndexContextProxy} Context.\n   */\n  getContext() {\n    return this.context_;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  draw(context) {\n    this.instructions_.forEach(instructionsAtIndex => {\n      for (let i = 0, ii = instructionsAtIndex.length; i < ii; ++i) {\n        const property = instructionsAtIndex[i];\n        if (typeof property === 'function') {\n          property(context);\n          continue;\n        }\n        const instructionAtIndex = instructionsAtIndex[++i];\n        if (typeof (/** @type {*} */context[property]) === 'function') {\n          /** @type {*} */context[property](...instructionAtIndex);\n        } else {\n          if (typeof instructionAtIndex === 'function') {\n            /** @type {*} */context[property] = instructionAtIndex(context);\n            continue;\n          }\n          /** @type {*} */\n          context[property] = instructionAtIndex;\n        }\n      }\n    });\n  }\n  clear() {\n    this.instructions_.length = 0;\n    this.zIndex = 0;\n    this.offset_ = 0;\n  }\n\n  /**\n   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to\n   * avoid conflicting context.clip() or context.save()/restore() calls.\n   */\n  offset() {\n    this.offset_ = this.instructions_.length;\n    this.zIndex = 0;\n  }\n}\nexport default ZIndexContext;", "/**\n * @module ol/renderer/canvas/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, makeInverse, toString as toTransformString } from '../../transform.js';\nimport { asArray } from '../../color.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { equals } from '../../array.js';\nimport { getBottomLeft, getBottomRight, getHeight, getTopLeft, getTopRight, getWidth } from '../../extent.js';\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true\n  });\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @private\n     * @type {ZIndexContext}\n     */\n    this.deferredContext_ = null;\n\n    /**\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {import('../../DataTile.js').ImageLike} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS Transform.\n   * @param {string} [backgroundColor] Background color.\n   */\n  useContainer(target, transform, backgroundColor) {\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals(asArray(target.style.backgroundColor), asArray(backgroundColor)))) {\n      const canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && context.canvas.style.transform === transform) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    } else if (this.container) {\n      this.container.style.backgroundColor = null;\n    }\n    if (!this.container) {\n      container = document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      context = createCanvasContext2D();\n      const canvas = context.canvas;\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n    if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {\n      this.container.style.backgroundColor = backgroundColor;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @protected\n   */\n  prepareContainer(frameState, target) {\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n    const width = Math.round(getWidth(extent) / resolution * pixelRatio);\n    const height = Math.round(getHeight(extent) / resolution * pixelRatio);\n    // set forward and inverse pixel transforms\n    composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n    const canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    if (!this.containerReused) {\n      const canvas = this.context.canvas;\n      if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n      } else {\n        this.context.clearRect(0, 0, width, height);\n      }\n      if (canvasTransform !== canvas.style.transform) {\n        canvas.style.transform = canvasTransform;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(type, this.inversePixelTransform, frameState, context);\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferredInternal(frameState) {}\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.\n   */\n  getRenderContext(frameState) {\n    if (frameState.declutter && !this.deferredContext_) {\n      this.deferredContext_ = new ZIndexContext();\n    }\n    return frameState.declutter ? this.deferredContext_.getContext() : this.context;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferred(frameState) {\n    if (!frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, this.context, frameState);\n    if (frameState.declutter && this.deferredContext_) {\n      this.deferredContext_.draw(this.context);\n      this.deferredContext_.clear();\n    }\n    this.renderDeferredInternal(frameState);\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, this.context, frameState);\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\nexport default CanvasLayerRenderer;", "/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport { createCanvasContext2D } from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image || data instanceof HTMLCanvasElement || data instanceof HTMLVideoElement || data instanceof ImageBitmap ? data : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array || data instanceof Uint8ClampedArray || data instanceof Float32Array || data instanceof DataView ? data : null;\n}\n\n/**\n * This is set as the cancellation reason when a tile is disposed.\n */\nexport const disposedError = new Error('disposed');\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(image.width, image.height, undefined, {\n      willReadFrequently: true\n    });\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @property {AbortController} [controller] An abort controller.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n\n    /**\n     * @type {AbortController|null}\n     * @private\n     */\n    this.controller_ = options.controller || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load the tile data.\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n    const self = this;\n    this.loader_().then(function (data) {\n      self.data_ = data;\n      self.state = TileState.LOADED;\n      self.changed();\n    }).catch(function (error) {\n      self.error_ = error;\n      self.state = TileState.ERROR;\n      self.changed();\n    });\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.controller_) {\n      this.controller_.abort(disposedError);\n      this.controller_ = null;\n    }\n    super.disposeInternal();\n  }\n}\nexport default DataTile;", "/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport { assert } from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n  deleteOldest() {\n    const entry = this.pop();\n    if (entry instanceof Disposable) {\n      entry.dispose();\n    }\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    while (this.oldest_) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(entry !== undefined, 'Tried to get a value for a key that does not exist in the cache');\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */this.oldest_.newer;\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(entry !== undefined, 'Tried to get a value for a key that does not exist in the cache');\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */entry.older;\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */entry.newer;\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */entry.newer;\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(!(key in this.entries_), 'Tried to set a value for a key that is used already');\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\nexport default LRUCache;", "/**\n * @module ol/vec/mat4\n */\n\n/** @typedef {Array<number>} Mat4 */\n\n/**\n * @return {Mat4} \"4x4 matrix representing a 3D identity transform.\"\n */\nexport function create() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\n/**\n * @param {Mat4} mat4 Flattened 4x4 matrix receiving the result.\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\n * @return {Mat4} \"2D transformation matrix as flattened 4x4 matrix.\"\n */\nexport function fromTransform(mat4, transform) {\n  mat4[0] = transform[0];\n  mat4[1] = transform[1];\n  mat4[4] = transform[2];\n  mat4[5] = transform[3];\n  mat4[12] = transform[4];\n  mat4[13] = transform[5];\n  return mat4;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @param {Mat4} [out] mat4 frustum matrix will be written into\n * @return {Mat4} out\n */\nexport function orthographic(left, right, bottom, top, near, far, out) {\n  out = out ?? create();\n  const lr = 1 / (left - right),\n    bt = 1 / (bottom - top),\n    nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3\n *\n * @param {Mat4} m The matrix to scale.\n * @param {number} x How much to scale in the x direction.\n * @param {number} y How much to scale in the y direction.\n * @param {number} z How much to scale in the z direction.\n * @param {Mat4} [out] The matrix to write to.\n * @return {Mat4} out\n **/\nexport function scale(m, x, y, z, out) {\n  out = out ?? create();\n  out[0] = m[0] * x;\n  out[1] = m[1] * x;\n  out[2] = m[2] * x;\n  out[3] = m[3] * x;\n  out[4] = m[4] * y;\n  out[5] = m[5] * y;\n  out[6] = m[6] * y;\n  out[7] = m[7] * y;\n  out[8] = m[8] * z;\n  out[9] = m[9] * z;\n  out[10] = m[10] * z;\n  out[11] = m[11] * z;\n  out[12] = m[12];\n  out[13] = m[13];\n  out[14] = m[14];\n  out[15] = m[15];\n  return out;\n}\n\n/**\n * Translate a matrix.\n *\n * @param {Mat4} m the matrix to translate\n * @param {number} x How much to translate in the x direction.\n * @param {number} y How much to translate in the y direction.\n * @param {number} z How much to translate in the z direction.\n * @param {Mat4} [out] the receiving matrix\n * @return {Mat4} out\n */\nexport function translate(m, x, y, z, out) {\n  out = out ?? create();\n  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;\n  if (m === out) {\n    out[12] = m[0] * x + m[4] * y + m[8] * z + m[12];\n    out[13] = m[1] * x + m[5] * y + m[9] * z + m[13];\n    out[14] = m[2] * x + m[6] * y + m[10] * z + m[14];\n    out[15] = m[3] * x + m[7] * y + m[11] * z + m[15];\n  } else {\n    a00 = m[0];\n    a01 = m[1];\n    a02 = m[2];\n    a03 = m[3];\n    a10 = m[4];\n    a11 = m[5];\n    a12 = m[6];\n    a13 = m[7];\n    a20 = m[8];\n    a21 = m[9];\n    a22 = m[10];\n    a23 = m[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + m[12];\n    out[13] = a01 * x + a11 * y + a21 * z + m[13];\n    out[14] = a02 * x + a12 * y + a22 * z + m[14];\n    out[15] = a03 * x + a13 * y + a23 * z + m[15];\n  }\n  return out;\n}\n\n/**\n * @param {number} x x translation.\n * @param {number} y y translation.\n * @param {number} z z translation.\n * @param {Mat4} [out] optional matrix to store result\n * @return {Mat4} out\n */\nexport function translation(x, y, z, out) {\n  out = out ?? create();\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = x;\n  out[13] = y;\n  out[14] = z;\n  out[15] = 1;\n  return out;\n}", "import * as mat4 from '../vec/mat4.js';\n\n/**\n * @module ol/webgl/Canvas\n */\n\nconst VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec4 a_texcoord;\n\n  uniform mat4 u_matrix;\n  uniform mat4 u_textureMatrix;\n\n  varying vec2 v_texcoord;\n\n  void main() {\n    gl_Position = u_matrix * a_position;\n    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;\n    v_texcoord = texcoord;\n  }\n`;\nconst FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (\n      v_texcoord.x < 0.0 ||\n      v_texcoord.y < 0.0 ||\n      v_texcoord.x > 1.0 ||\n      v_texcoord.y > 1.0\n    ) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/** @typedef {import(\"../transform.js\").Transform} Matrix */\n\n/**\n * Canvas-like operations implemented in webgl.\n */\nexport class Canvas {\n  /**\n   * @param {WebGLRenderingContext} gl Context to render in.\n   */\n  constructor(gl) {\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = gl;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.program_ = createProgram(gl, FRAGMENT_SHADER, VERTEX_SHADER);\n    this.positionLocation = gl.getAttribLocation(this.program_, 'a_position');\n    this.texcoordLocation = gl.getAttribLocation(this.program_, 'a_texcoord');\n    this.matrixLocation = gl.getUniformLocation(this.program_, 'u_matrix');\n    this.textureMatrixLocation = gl.getUniformLocation(this.program_, 'u_textureMatrix');\n    this.textureLocation = gl.getUniformLocation(this.program_, 'u_texture');\n    this.positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n    this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.positions), gl.STATIC_DRAW);\n    this.texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n    this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.texcoords), gl.STATIC_DRAW);\n  }\n\n  /**\n   * 2dContext drawImage call implemented in webgl.\n   * Unlike images, textures do not have a width and height associated\n   * with them so we'll pass in the width and height of the texture.\n   *\n   * @param {WebGLTexture} tex Image to draw.\n   * @param {number} texWidth Image width.\n   * @param {number} texHeight Image height.\n   * @param {number} srcX Top-left x-point to read src image.\n   * @param {number} srcY Top-left y-point to read src image.\n   * @param {number} [srcWidth] Width of source to read.\n   * @param {number} [srcHeight] Height of source to read.\n   * @param {number} [dstX] Top-left x-point of destination.\n   * @param {number} [dstY] Top-left y-point of destination.\n   * @param {number} [dstWidth] Width of written image in destination.\n   * @param {number} [dstHeight] Height of written image in destination.\n   * @param {number} [width] Width of canvas.\n   * @param {number} [height] Height of canvas.\n   */\n  drawImage(tex, texWidth, texHeight, srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, width, height) {\n    const gl = this.gl_;\n    if (dstX === undefined) {\n      dstX = srcX;\n    }\n    if (dstY === undefined) {\n      dstY = srcY;\n    }\n    if (srcWidth === undefined) {\n      srcWidth = texWidth;\n    }\n    if (srcHeight === undefined) {\n      srcHeight = texHeight;\n    }\n    if (dstWidth === undefined) {\n      dstWidth = srcWidth;\n    }\n    if (dstHeight === undefined) {\n      dstHeight = srcHeight;\n    }\n    if (width === undefined) {\n      width = gl.canvas.width;\n    }\n    if (height === undefined) {\n      height = gl.canvas.height;\n    }\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.useProgram(this.program_);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n    gl.enableVertexAttribArray(this.positionLocation);\n    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n    gl.enableVertexAttribArray(this.texcoordLocation);\n    gl.vertexAttribPointer(this.texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // matrix for converting pixels to clip space\n    let matrix = mat4.orthographic(0, width, 0, height, -1, 1);\n    matrix = mat4.translate(matrix, dstX, dstY, 0);\n    matrix = mat4.scale(matrix, dstWidth, dstHeight, 1);\n    gl.uniformMatrix4fv(this.matrixLocation, false, matrix);\n    let texMatrix = mat4.translation(srcX / texWidth, srcY / texHeight, 0);\n    texMatrix = mat4.scale(texMatrix, srcWidth / texWidth, srcHeight / texHeight, 1);\n    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\n    gl.uniform1i(this.textureLocation, 0);\n    gl.drawArrays(gl.TRIANGLES, 0, this.positions.length / 2);\n  }\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {GLenum} type Type of shader.\n * @param {string} source source of shader.\n * @return {WebGLShader} [progam] The program.\n */\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  if (shader === null) {\n    throw new Error('Shader compilation failed');\n  }\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const log = gl.getShaderInfoLog(shader);\n    if (log === null) {\n      throw new Error('Shader info log creation failed');\n    }\n    throw new Error(log);\n  }\n  return shader;\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {string} fragmentSource Fragment shader source.\n * @param {string} vertexSource Vertex shader source.\n * @return {WebGLProgram} [progam] The program.\n */\nexport function createProgram(gl, fragmentSource, vertexSource) {\n  const program = gl.createProgram();\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n  if (program === null) {\n    throw new Error('Program creation failed');\n  }\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const log = gl.getProgramInfoLog(program);\n    if (log === null) {\n      throw new Error('Program info log creation failed');\n    }\n    throw new Error();\n  }\n  return program;\n}", "/**\n * @module ol/reproj/glreproj\n */\nimport * as mat4 from '../vec/mat4.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../has.js';\nimport { Canvas as WebGLCanvas, createProgram } from '../webgl/Canvas.js';\nimport { createEmpty, extend, getHeight, getTopLeft, getWidth } from '../extent.js';\nconst EDGE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n  }\n`;\nconst EDGE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  uniform vec4 u_val;\n  void main() {\n     gl_FragColor = u_val;\n  }\n`;\nconst TRIANGLE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec2 a_texcoord;\n\n  varying vec2 v_texcoord;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n     v_texcoord = a_texcoord;\n  }\n`;\nconst TRIANGLE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/**\n * Create an html canvas element and returns its webgl context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement | OffscreenCanvas>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {WebGLContextAttributes} [settings] CanvasRenderingContext2DSettings\n * @return {WebGLRenderingContext} The context.\n */\nexport function createCanvasContextWebGL(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (canvasPool && canvasPool.length) {\n    canvas = /** @type {HTMLCanvasElement} */canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (width) {\n    canvas.width = width;\n  }\n  if (height) {\n    canvas.height = height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {WebGLRenderingContext} */canvas.getContext('webgl', settings);\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {WebGLRenderingContext} gl Context.\n */\nexport function releaseGLCanvas(gl) {\n  const canvas = gl.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n}\n\n/**\n * @type {Array<HTMLCanvasElement | OffscreenCanvas>}\n */\nexport const canvasGLPool = [];\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"../extent.js\").Extent} extent Extent.\n * @property {import(\"../extent.js\").Extent} [clipExtent] Clip extent.\n * @property {WebGLTexture} texture Texture.\n * @property {number} width Width of texture.\n * @property {number} height Height of texture.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {WebGLRenderingContext} gl the context to render in.\n * @param {number} width_ Width of the canvas.\n * @param {number} height_ Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"../extent.js\").Extent} targetExtent Target extent (tile).\n * @param {import(\"../reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {number} dataType What kind of data is the textures, must be gl.FLOAT or gl.UNSIGNED_BYTE\n * TODO: Allow setting renderEdges value in the data as this is done in \"data-space\".\n * @param {boolean | Array<number>} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchTexture.\n * @return {{framebuffer: WebGLFramebuffer, width: number, height: number, texture: WebGLTexture}} Canvas with reprojected data.\n */\nexport function render(gl, width_, height_, pixelRatio, sourceResolution, targetResolution, targetExtent, triangulation, sources, gutter, dataType, renderEdges, interpolate, drawSingle) {\n  const width = Math.round(pixelRatio * width_);\n  const height = Math.round(pixelRatio * height_);\n  gl.canvas.width = width;\n  gl.canvas.height = height;\n\n  /** @type {WebGLFramebuffer | null} */\n  let resultFrameBuffer;\n  /** @type {WebGLTexture | null} */\n  let resultTexture;\n  {\n    resultTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, resultTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, dataType, null);\n    resultFrameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, resultTexture, 0);\n  }\n  if (resultFrameBuffer === null) {\n    throw new Error('Could not create framebuffer');\n  }\n  if (resultTexture === null) {\n    throw new Error('Could not create texture');\n  }\n  if (sources.length === 0) {\n    return {\n      width,\n      height,\n      framebuffer: resultFrameBuffer,\n      texture: resultTexture\n    };\n  }\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  /** @type {WebGLTexture | null} */\n  let stitchTexture;\n  /** @type {number} */\n  let stitchWidth;\n  /** @type {number} */\n  let stitchHeight;\n  const stitchScale = 1 / sourceResolution;\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchTexture = gl.createTexture();\n    if (resultTexture === null) {\n      throw new Error('Could not create texture');\n    }\n    stitchWidth = Math.round(getWidth(sourceDataExtent) * stitchScale);\n    stitchHeight = Math.round(getHeight(sourceDataExtent) * stitchScale);\n\n    // Make sure we do not exceed the max texture size by lowering the resolution for this image.\n    // https://github.com/openlayers/openlayers/pull/15860#issuecomment-2254123580\n    const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    const largeSide = Math.max(stitchWidth, stitchHeight);\n    const scaleFactor = largeSide > maxTexSize ? maxTexSize / largeSide : 1;\n    const stitchWidthFixed = Math.round(stitchWidth * scaleFactor);\n    const stitchHeightFixed = Math.round(stitchHeight * scaleFactor);\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, stitchWidthFixed, stitchHeightFixed, 0, gl.RGBA, dataType, null);\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, stitchTexture, 0);\n    const webGLCanvas = new WebGLCanvas(gl);\n    sources.forEach(function (src, i, arr) {\n      const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n      const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;\n      const srcWidth = getWidth(src.extent) * stitchScale * scaleFactor;\n      const srcHeight = getHeight(src.extent) * stitchScale * scaleFactor;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n      gl.viewport(0, 0, stitchWidthFixed, stitchHeightFixed);\n      if (src.clipExtent) {\n        const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n        const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;\n        const width = getWidth(src.clipExtent) * stitchScale * scaleFactor;\n        const height = getHeight(src.clipExtent) * stitchScale * scaleFactor;\n        gl.enable(gl.SCISSOR_TEST);\n        gl.scissor(interpolate ? xPos : Math.round(xPos), interpolate ? yPos : Math.round(yPos), interpolate ? width : Math.round(xPos + width) - Math.round(xPos), interpolate ? height : Math.round(yPos + height) - Math.round(yPos));\n      }\n      webGLCanvas.drawImage(src.texture, src.width, src.height, gutter, gutter, src.width - 2 * gutter, src.height - 2 * gutter, interpolate ? xPos : Math.round(xPos), interpolate ? yPos : Math.round(yPos), interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos), interpolate ? srcHeight : Math.round(yPos + srcHeight) - Math.round(yPos), stitchWidthFixed, stitchHeightFixed);\n      gl.disable(gl.SCISSOR_TEST);\n    });\n    gl.deleteFramebuffer(fb);\n  } else {\n    stitchTexture = sources[0].texture;\n    stitchWidth = sources[0].width;\n    stitchHeight = sources[0].width;\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n  const sourceTopLeft = getTopLeft(sourceDataExtent);\n  const getUVs = (/** @type {Array<import(\"../coordinate.js\").Coordinate>} */target) => {\n    const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution * pixelRatio;\n    const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution * pixelRatio;\n    const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution * pixelRatio;\n    const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution * pixelRatio;\n    const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution * pixelRatio;\n    const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution * pixelRatio;\n    return {\n      u1,\n      v1,\n      u0,\n      v0,\n      u2,\n      v2\n    };\n  };\n  gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n  gl.viewport(0, 0, width, height);\n\n  // Draw source to reprojtile\n  {\n    /** @type {Array<number>} */\n    const vertices = [];\n    /** @type {Array<number>} */\n    const texcoords = [];\n    const triProgram = createProgram(gl, TRIANGLE_FRAGMENT_SHADER, TRIANGLE_VERTEX_SHADER);\n    gl.useProgram(triProgram);\n\n    // Bind image\n    const textureLocation = gl.getUniformLocation(triProgram, 'u_texture');\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    // Tell the shader to get the texture from texture unit 0\n    gl.uniform1i(textureLocation, 0);\n\n    // Calculate vert and tex coordinates.\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const source = triangle.source;\n      const target = triangle.target;\n      // Make sure that everything is on pixel boundaries\n      const {\n        u1,\n        v1,\n        u0,\n        v0,\n        u2,\n        v2\n      } = getUVs(target);\n      const su0 = (source[0][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv0 = -(source[0][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su1 = (source[1][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv1 = -(source[1][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su2 = (source[2][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv2 = -(source[2][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      vertices.push(u1, v1, u0, v0, u2, v2);\n      texcoords.push(su1, sv1, su0, sv0, su2, sv2);\n    });\n\n    // Convert pixel space to clip space.\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(triProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n    const positionLocation = gl.getAttribLocation(triProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n    const texcoordLocation = gl.getAttribLocation(triProgram, 'a_texcoord');\n    const texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(texcoordLocation);\n    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);\n  }\n  if (renderEdges) {\n    const edgeProgram = createProgram(gl, EDGE_FRAGMENT_SHADER, EDGE_VERTEX_SHADER);\n    gl.useProgram(edgeProgram);\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(edgeProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n    const burnval = Array.isArray(renderEdges) ? renderEdges : [0, 0, 0, 255];\n    const burnvalLocation = gl.getUniformLocation(edgeProgram, 'u_val');\n    const isFloat = true;\n    if (isFloat) {\n      gl.uniform4fv(burnvalLocation, burnval);\n    } else {\n      gl.uniform4iv(burnvalLocation, burnval);\n    }\n    const positionLocation = gl.getAttribLocation(edgeProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    /** @type {Array<number>} */\n    const lines = triangulation.getTriangles().reduce(function (/** @type {Array<number>} */lines, triangle) {\n      const target = triangle.target;\n      const {\n        u1,\n        v1,\n        u0,\n        v0,\n        u2,\n        v2\n      } = getUVs(target);\n      return lines.concat([u1, v1, u0, v0, u0, v0, u2, v2, u2, v2, u1, v1]);\n    }, []);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);\n    gl.drawArrays(gl.LINES, 0, lines.length / 2);\n  }\n  return {\n    width,\n    height,\n    framebuffer: resultFrameBuffer,\n    texture: resultTexture\n  };\n}", "/**\n * @module ol/reproj/DataTile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport DataTile, { asArrayLike, asImageLike, toArray } from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution } from '../reproj.js';\nimport { canvasGLPool, createCanvasContextWebGL, releaseGLCanvas, render as renderReprojected } from './glreproj.js';\nimport { clamp } from '../math.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { getArea, getIntersection, getWidth, wrapAndSliceX } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {import(\"../transform.js\").Transform} [transformMatrix] Source transform matrix.\n * @property {boolean} [renderEdges] Render reprojection edges.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\n      interpolate: options.interpolate,\n      transition: options.transition\n    });\n\n    /**\n     * @private\n     * @type {boolean | Array<number>}\n     */\n    this.renderEdges_ = options.renderEdges !== undefined ? options.renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX() ? sourceTileGridExtent ? getIntersection(sourceProjExtent, sourceTileGridExtent) : sourceProjExtent : sourceTileGridExtent;\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    const targetResolution = this.targetTileGrid_.getResolution(this.wrappedTileCoord_[0]);\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n    const errorThresholdInPixels = options.errorThreshold !== undefined ? options.errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution, options.transformMatrix);\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor((sourceExtent[0] - sourceProjExtent[0]) / worldWidth);\n      }\n      const sourceExtents = wrapAndSliceX(sourceExtent.slice(), sourceProj, true);\n      sourceExtents.forEach(extent => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(extent, this.sourceZ_);\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({\n                tile,\n                offset\n              });\n            }\n          }\n        }\n        ++worldsAway;\n      });\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   * @override\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   * @override\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @override\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    let imageLike = false;\n    this.sourceTiles_.forEach(source => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        imageLike = true;\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = bytesPerElement * tileDataR.length / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: tileDataR,\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n        bandCount: bandCount\n      });\n    });\n    this.sourceTiles_.length = 0;\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n      this.changed();\n      return;\n    }\n    const z = this.wrappedTileCoord_[0];\n    const size = this.targetTileGrid_.getTileSize(z);\n    const targetWidth = typeof size === 'number' ? size : size[0];\n    const targetHeight = typeof size === 'number' ? size : size[1];\n    const outWidth = targetWidth * this.pixelRatio_;\n    const outHeight = targetHeight * this.pixelRatio_;\n    const targetResolution = this.targetTileGrid_.getResolution(z);\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n    const bandCount = dataSources[0].bandCount;\n    const dataR = new dataSources[0].dataType(bandCount * outWidth * outHeight);\n    const gl = createCanvasContextWebGL(outWidth, outHeight, canvasGLPool, {\n      premultipliedAlpha: false,\n      antialias: false\n    });\n    let willInterpolate;\n    const format = gl.RGBA;\n    let textureType;\n    if (dataSources[0].dataType == Float32Array) {\n      textureType = gl.FLOAT;\n      gl.getExtension('WEBGL_color_buffer_float');\n      gl.getExtension('OES_texture_float');\n      gl.getExtension('EXT_float_blend');\n      const extension = gl.getExtension('OES_texture_float_linear');\n      const canInterpolate = extension !== null;\n      willInterpolate = canInterpolate && this.interpolate;\n    } else {\n      textureType = gl.UNSIGNED_BYTE;\n      willInterpolate = this.interpolate;\n    }\n    const BANDS_PR_REPROJ = 4;\n    const reprojs = Math.ceil(bandCount / BANDS_PR_REPROJ);\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n      const sources = [];\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\n        const dataSource = dataSources[i];\n        const pixelSize = dataSource.pixelSize;\n        const width = pixelSize[0];\n        const height = pixelSize[1];\n        const data = new dataSource.dataType(BANDS_PR_REPROJ * width * height);\n        const dataS = dataSource.data;\n        let offset = reproj * BANDS_PR_REPROJ;\n        for (let j = 0, len = data.length; j < len; j += BANDS_PR_REPROJ) {\n          data[j] = dataS[offset];\n          data[j + 1] = dataS[offset + 1];\n          data[j + 2] = dataS[offset + 2];\n          data[j + 3] = dataS[offset + 3];\n          offset += bandCount;\n        }\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        if (willInterpolate) {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        } else {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        }\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, textureType, data);\n        sources.push({\n          extent: dataSource.extent,\n          clipExtent: dataSource.clipExtent,\n          texture: texture,\n          width: width,\n          height: height\n        });\n      }\n      const {\n        framebuffer,\n        width,\n        height\n      } = renderReprojected(gl, targetWidth, targetHeight, this.pixelRatio_, sourceResolution, targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, textureType, this.renderEdges_, willInterpolate);\n\n      // The texture is always RGBA.\n      const rows = width;\n      const cols = height * BANDS_PR_REPROJ;\n      const data = new dataSources[0].dataType(rows * cols);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.readPixels(0, 0, width, height, gl.RGBA, textureType, data);\n      let offset = reproj * BANDS_PR_REPROJ;\n      for (let i = 0, len = data.length; i < len; i += BANDS_PR_REPROJ) {\n        // The data read by `readPixels` is flipped in the y-axis so flip it again.\n        const flipY = (rows - 1 - (i / cols | 0)) * cols + i % cols;\n        dataR[offset] = data[flipY];\n        dataR[offset + 1] = data[flipY + 1];\n        dataR[offset + 2] = data[flipY + 2];\n        dataR[offset + 3] = data[flipY + 3];\n        offset += bandCount;\n      }\n    }\n    releaseGLCanvas(gl);\n    canvasGLPool.push(gl.canvas);\n    if (imageLike) {\n      const context = createCanvasContext2D(targetWidth, targetHeight);\n      const imageData = new ImageData(dataR, targetWidth);\n      context.putImageData(imageData, 0, 0);\n      this.reprojData_ = context.canvas;\n    } else {\n      this.reprojData_ = dataR;\n    }\n    this.reprojSize_ = [Math.round(outWidth), Math.round(outHeight)];\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n    let leftToLoad = 0;\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({\n      tile\n    }) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\n        const state = tile.getState();\n        if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n          unlistenByKey(sourceListenKey);\n          leftToLoad--;\n          if (leftToLoad === 0) {\n            this.unlistenSources_();\n            this.reproject_();\n          }\n        }\n      });\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({\n        tile\n      }) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\nexport default ReprojDataTile;", "/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport DataTile, { asImageLike } from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { apply as applyTransform, compose as composeTransform } from '../../transform.js';\nimport { ascending } from '../../array.js';\nimport { containsCoordinate, createEmpty, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport { createOrUpdate as createTileCoord, getKeyZXY } from '../../tilecoord.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */\n  layerState.layer.getRenderSource();\n  if (!source.getWrapX()) {\n    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(z, x, y, frameState.pixelRatio, frameState.viewState.projection);\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n    const layer = this.getLayer();\n    const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n      const col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n      const row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n      const gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);\n      const tileResolution = tileGrid.getResolution(z);\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.get(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n    if (!tileRange) {\n      return false;\n    }\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.get(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    let allTilesIdle = true;\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  * maybe skip transition when not fully opaque\n     *  * decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(frameExtent, fromUserExtent(layerState.extent, projection));\n    }\n    const dx = tileResolution * width / 2 / tilePixelRatio;\n    const dy = tileResolution * height / 2 / tilePixelRatio;\n    const canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(frameState, renderExtent, z - 1, tilesByZ, preload - 1);\n      }, 0);\n    }\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if ((tile instanceof ReprojTile || tile instanceof ReprojDataTile) && tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.IDLE) {\n        allTilesIdle = false;\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tilesByZ);\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tilesByZ);\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (intersects([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.postRender(this.context, frameState);\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n    if (!this.renderComplete && !allTilesIdle) {\n      frameState.animate = true;\n    }\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(this.tileCache_.highWaterMark, tileCount * 2);\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(/** @type {import(\"../../ImageTile.js\").default} */tile);\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\nexport default CanvasTileLayerRenderer;", "/**\n * @module ol/layer/Tile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} [TileSourceType=import(\"../source/Tile.js\").default]\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this, {\n      cacheSize: this.getCacheSize()\n    });\n  }\n}\nexport default TileLayer;"],
  "mappings": "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",
  "names": ["Layer_default", "render", "Layer_default", "EventType_default", "create", "create", "xPos", "yPos", "width", "height", "lines", "size", "bandCount", "width", "height", "data", "offset", "len", "state", "DataTile_default", "Layer_default", "Tile_default", "DataTile_default", "dx", "dy", "i", "equals", "frameState", "Tile_default"]
}
