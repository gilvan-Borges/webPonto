{
  "version": 3,
  "sources": ["../../../../../../node_modules/ol/renderer/Map.js", "../../../../../../node_modules/ol/renderer/Composite.js", "../../../../../../node_modules/ol/layer/Group.js", "../../../../../../node_modules/ol/MapEvent.js", "../../../../../../node_modules/ol/MapBrowserEvent.js", "../../../../../../node_modules/ol/MapBrowserEventType.js", "../../../../../../node_modules/ol/pointer/EventType.js", "../../../../../../node_modules/ol/MapBrowserEventHandler.js", "../../../../../../node_modules/ol/MapProperty.js", "../../../../../../node_modules/ol/structs/PriorityQueue.js", "../../../../../../node_modules/ol/TileQueue.js", "../../../../../../node_modules/ol/control/Control.js", "../../../../../../node_modules/ol/control/Attribution.js", "../../../../../../node_modules/ol/control/Rotate.js", "../../../../../../node_modules/ol/control/Zoom.js", "../../../../../../node_modules/ol/control/defaults.js", "../../../../../../node_modules/ol/interaction/Property.js", "../../../../../../node_modules/ol/interaction/Interaction.js", "../../../../../../node_modules/ol/interaction/DoubleClickZoom.js", "../../../../../../node_modules/ol/interaction/Pointer.js", "../../../../../../node_modules/ol/events/condition.js", "../../../../../../node_modules/ol/interaction/DragPan.js", "../../../../../../node_modules/ol/interaction/DragRotate.js", "../../../../../../node_modules/ol/render/Box.js", "../../../../../../node_modules/ol/interaction/DragBox.js", "../../../../../../node_modules/ol/interaction/DragZoom.js", "../../../../../../node_modules/ol/events/Key.js", "../../../../../../node_modules/ol/interaction/KeyboardPan.js", "../../../../../../node_modules/ol/interaction/KeyboardZoom.js", "../../../../../../node_modules/ol/Kinetic.js", "../../../../../../node_modules/ol/interaction/MouseWheelZoom.js", "../../../../../../node_modules/ol/interaction/PinchRotate.js", "../../../../../../node_modules/ol/interaction/PinchZoom.js", "../../../../../../node_modules/ol/interaction/defaults.js", "../../../../../../node_modules/ol/Map.js"],
  "sourcesContent": ["/**\r\n * @module ol/renderer/Map\r\n */\nimport Disposable from '../Disposable.js';\nimport { TRUE } from '../functions.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, makeInverse } from '../transform.js';\nimport { getWidth } from '../extent.js';\nimport { shared as iconImageCache } from '../style/IconImageCache.js';\nimport { inView } from '../layer/Layer.js';\nimport { wrapX } from '../coordinate.js';\n\n/**\r\n * @template T\r\n * @typedef HitMatch\r\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\r\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\r\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\r\n * @property {number} distanceSq Squared distance.\r\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\r\n */\n\n/**\r\n * @abstract\r\n */\nclass MapRenderer extends Disposable {\n  /**\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   */\n  constructor(map) {\n    super();\n\n    /**\r\n     * @private\r\n     * @type {import(\"../Map.js\").default}\r\n     */\n    this.map_ = map;\n  }\n\n  /**\r\n   * @abstract\r\n   * @param {import(\"../render/EventType.js\").default} type Event type.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\n  dispatchRenderEvent(type, frameState) {\n    abstract();\n  }\n\n  /**\r\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\r\n   * @protected\r\n   */\n  calculateMatrices2D(frameState) {\n    const viewState = frameState.viewState;\n    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n    composeTransform(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  }\n\n  /**\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @param {boolean} checkWrapped Check for wrapped geometries.\r\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\r\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\r\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\r\n   *     function, only layers which are visible and for which this function\r\n   *     returns `true` will be tested for features.  By default, all visible\r\n   *     layers will be tested.\r\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\r\n   * @return {T|undefined} Callback result.\r\n   * @template S,T,U\r\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {\n    let result;\n    const viewState = frameState.viewState;\n\n    /**\r\n     * @param {boolean} managed Managed layer.\r\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\r\n     * @param {import(\"../layer/Layer.js\").default} layer Layer.\r\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\r\n     * @return {T|undefined} Callback result.\r\n     */\n    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n      return callback.call(thisArg, feature, managed ? layer : null, geometry);\n    }\n    const projection = viewState.projection;\n    const translatedCoordinate = wrapX(coordinate.slice(), projection);\n    const offsets = [[0, 0]];\n    if (projection.canWrapX() && checkWrapped) {\n      const projectionExtent = projection.getExtent();\n      const worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n    const layerStates = frameState.layerStatesArray;\n    const numLayers = layerStates.length;\n    const matches = /** @type {Array<HitMatch<T>>} */[];\n    const tmpCoord = [];\n    for (let i = 0; i < offsets.length; i++) {\n      for (let j = numLayers - 1; j >= 0; --j) {\n        const layerState = layerStates[j];\n        const layer = layerState.layer;\n        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {\n          const layerRenderer = layer.getRenderer();\n          const source = layer.getSource();\n          if (layerRenderer && source) {\n            const coordinates = source.getWrapX() ? translatedCoordinate : coordinate;\n            const callback = forEachFeatureAtCoordinate.bind(null, layerState.managed);\n            tmpCoord[0] = coordinates[0] + offsets[i][0];\n            tmpCoord[1] = coordinates[1] + offsets[i][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback, matches);\n          }\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    if (matches.length === 0) {\n      return undefined;\n    }\n    const order = 1 / matches.length;\n    matches.forEach((m, i) => m.distanceSq += i * order);\n    matches.sort((a, b) => a.distanceSq - b.distanceSq);\n    matches.some(m => {\n      return result = m.callback(m.feature, m.layer, m.geometry);\n    });\n    return result;\n  }\n\n  /**\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @param {boolean} checkWrapped Check for wrapped geometries.\r\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\r\n   *     function, only layers which are visible and for which this function\r\n   *     returns `true` will be tested for features.  By default, all visible\r\n   *     layers will be tested.\r\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\r\n   * @return {boolean} Is there a feature at the given coordinate?\r\n   * @template U\r\n   */\n  hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {\n    const hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);\n    return hasFeature !== undefined;\n  }\n\n  /**\r\n   * @return {import(\"../Map.js\").default} Map.\r\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\r\n   * Render.\r\n   * @abstract\r\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\n  renderFrame(frameState) {\n    abstract();\n  }\n\n  /**\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\n  scheduleExpireIconCache(frameState) {\n    if (iconImageCache.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  }\n}\n\n/**\r\n * @param {import(\"../Map.js\").default} map Map.\r\n * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n */\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\nexport default MapRenderer;", "/**\r\n * @module ol/renderer/Composite\r\n */\nimport BaseVectorLayer from '../layer/BaseVector.js';\nimport MapRenderer from './Map.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport RenderEvent from '../render/Event.js';\nimport RenderEventType from '../render/EventType.js';\nimport { CLASS_UNSELECTABLE } from '../css.js';\nimport { checkedFonts } from '../render/canvas.js';\nimport { inView } from '../layer/Layer.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { replaceChildren } from '../dom.js';\n\n/**\r\n * @classdesc\r\n * Canvas map renderer.\r\n * @api\r\n */\nclass CompositeMapRenderer extends MapRenderer {\n  /**\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   */\n  constructor(map) {\n    super(map);\n\n    /**\r\n     * @private\r\n     * @type {import(\"../events.js\").EventsKey}\r\n     */\n    this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, map.redrawText, map);\n\n    /**\r\n     * @private\r\n     * @type {HTMLDivElement}\r\n     */\n    this.element_ = document.createElement('div');\n    const style = this.element_.style;\n    style.position = 'absolute';\n    style.width = '100%';\n    style.height = '100%';\n    style.zIndex = '0';\n    this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';\n    const container = map.getViewport();\n    container.insertBefore(this.element_, container.firstChild || null);\n\n    /**\r\n     * @private\r\n     * @type {Array<HTMLElement>}\r\n     */\n    this.children_ = [];\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.renderedVisible_ = true;\n  }\n\n  /**\r\n   * @param {import(\"../render/EventType.js\").default} type Event type.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @override\r\n   */\n  dispatchRenderEvent(type, frameState) {\n    const map = this.getMap();\n    if (map.hasListener(type)) {\n      const event = new RenderEvent(type, undefined, frameState);\n      map.dispatchEvent(event);\n    }\n  }\n\n  /**\r\n   * @override\r\n   */\n  disposeInternal() {\n    unlistenByKey(this.fontChangeListenerKey_);\n    this.element_.remove();\n    super.disposeInternal();\n  }\n\n  /**\r\n   * Render.\r\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @override\r\n   */\n  renderFrame(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element_.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n    this.calculateMatrices2D(frameState);\n    this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);\n    const layerStatesArray = frameState.layerStatesArray.sort((a, b) => a.zIndex - b.zIndex);\n    const declutter = layerStatesArray.some(layerState => layerState.layer instanceof BaseVectorLayer && layerState.layer.getDeclutter());\n    if (declutter) {\n      // Some layers need decluttering, turn on deferred rendering hint\n      frameState.declutter = {};\n    }\n    const viewState = frameState.viewState;\n    this.children_.length = 0;\n    const renderedLayerStates = [];\n    let previousElement = null;\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      const layerState = layerStatesArray[i];\n      frameState.layerIndex = i;\n      const layer = layerState.layer;\n      const sourceState = layer.getSourceState();\n      if (!inView(layerState, viewState) || sourceState != 'ready' && sourceState != 'undefined') {\n        layer.unrender();\n        continue;\n      }\n      const element = layer.render(frameState, previousElement);\n      if (!element) {\n        continue;\n      }\n      if (element !== previousElement) {\n        this.children_.push(element);\n        previousElement = element;\n      }\n      renderedLayerStates.push(layerState);\n    }\n    this.declutter(frameState, renderedLayerStates);\n    replaceChildren(this.element_, this.children_);\n    this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);\n    if (!this.renderedVisible_) {\n      this.element_.style.display = '';\n      this.renderedVisible_ = true;\n    }\n    this.scheduleExpireIconCache(frameState);\n  }\n\n  /**\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.\r\n   */\n  declutter(frameState, layerStates) {\n    if (!frameState.declutter) {\n      return;\n    }\n    for (let i = layerStates.length - 1; i >= 0; --i) {\n      const layerState = layerStates[i];\n      const layer = layerState.layer;\n      if (layer.getDeclutter()) {\n        layer.renderDeclutter(frameState, layerState);\n      }\n    }\n    layerStates.forEach(layerState => layerState.layer.renderDeferred(frameState));\n  }\n}\nexport default CompositeMapRenderer;", "/**\r\n * @module ol/layer/Group\r\n */\nimport BaseLayer from './Base.js';\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport { assert } from '../asserts.js';\nimport { clear } from '../obj.js';\nimport { getIntersection } from '../extent.js';\nimport { getUid } from '../util.js';\nimport { listen, unlistenByKey } from '../events.js';\n\n/**\r\n * @typedef {'addlayer'|'removelayer'} GroupEventType\r\n */\n\n/**\r\n * @classdesc\r\n * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from\r\n * the group or one of its child groups.  When a layer group is added to or removed from another layer group,\r\n * a single event will be triggered (instead of one per layer in the group added or removed).\r\n */\nexport class GroupEvent extends Event {\n  /**\r\n   * @param {GroupEventType} type The event type.\r\n   * @param {BaseLayer} layer The layer.\r\n   */\n  constructor(type, layer) {\n    super(type);\n\n    /**\r\n     * The added or removed layer.\r\n     * @type {BaseLayer}\r\n     * @api\r\n     */\n    this.layer = layer;\n  }\n}\n\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\r\n *     'change:layers', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature\r\n */\n\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {Array<import(\"./Base.js\").default>|Collection<import(\"./Base.js\").default>} [layers] Child layers.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\n\n/**\r\n * @enum {string}\r\n * @private\r\n */\nconst Property = {\n  LAYERS: 'layers'\n};\n\n/**\r\n * @classdesc\r\n * A {@link module:ol/Collection~Collection} of layers that are handled together.\r\n *\r\n * A generic `change` event is triggered when the group/Collection changes.\r\n *\r\n * @api\r\n */\nclass LayerGroup extends BaseLayer {\n  /**\r\n   * @param {Options} [options] Layer options.\r\n   */\n  constructor(options) {\n    options = options || {};\n    const baseOptions = /** @type {Options} */Object.assign({}, options);\n    delete baseOptions.layers;\n    let layers = options.layers;\n    super(baseOptions);\n\n    /***\r\n     * @type {GroupOnSignature<import(\"../events\").EventsKey>}\r\n     */\n    this.on;\n\n    /***\r\n     * @type {GroupOnSignature<import(\"../events\").EventsKey>}\r\n     */\n    this.once;\n\n    /***\r\n     * @type {GroupOnSignature<void>}\r\n     */\n    this.un;\n\n    /**\r\n     * @private\r\n     * @type {Array<import(\"../events.js\").EventsKey>}\r\n     */\n    this.layersListenerKeys_ = [];\n\n    /**\r\n     * @private\r\n     * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\r\n     */\n    this.listenerKeys_ = {};\n    this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);\n    if (layers) {\n      if (Array.isArray(layers)) {\n        layers = new Collection(layers.slice(), {\n          unique: true\n        });\n      } else {\n        assert(typeof (/** @type {?} */layers.getArray) === 'function', 'Expected `layers` to be an array or a `Collection`');\n      }\n    } else {\n      layers = new Collection(undefined, {\n        unique: true\n      });\n    }\n    this.setLayers(layers);\n  }\n\n  /**\r\n   * @private\r\n   */\n  handleLayerChange_() {\n    this.changed();\n  }\n\n  /**\r\n   * @private\r\n   */\n  handleLayersChanged_() {\n    this.layersListenerKeys_.forEach(unlistenByKey);\n    this.layersListenerKeys_.length = 0;\n    const layers = this.getLayers();\n    this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));\n    for (const id in this.listenerKeys_) {\n      this.listenerKeys_[id].forEach(unlistenByKey);\n    }\n    clear(this.listenerKeys_);\n    const layersArray = layers.getArray();\n    for (let i = 0, ii = layersArray.length; i < ii; i++) {\n      const layer = layersArray[i];\n      this.registerLayerListeners_(layer);\n      this.dispatchEvent(new GroupEvent('addlayer', layer));\n    }\n    this.changed();\n  }\n\n  /**\r\n   * @param {BaseLayer} layer The layer.\r\n   */\n  registerLayerListeners_(layer) {\n    const listenerKeys = [listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this), listen(layer, EventType.CHANGE, this.handleLayerChange_, this)];\n    if (layer instanceof LayerGroup) {\n      listenerKeys.push(listen(layer, 'addlayer', this.handleLayerGroupAdd_, this), listen(layer, 'removelayer', this.handleLayerGroupRemove_, this));\n    }\n    this.listenerKeys_[getUid(layer)] = listenerKeys;\n  }\n\n  /**\r\n   * @param {GroupEvent} event The layer group event.\r\n   */\n  handleLayerGroupAdd_(event) {\n    this.dispatchEvent(new GroupEvent('addlayer', event.layer));\n  }\n\n  /**\r\n   * @param {GroupEvent} event The layer group event.\r\n   */\n  handleLayerGroupRemove_(event) {\n    this.dispatchEvent(new GroupEvent('removelayer', event.layer));\n  }\n\n  /**\r\n   * @param {import(\"../Collection.js\").CollectionEvent<import(\"./Base.js\").default>} collectionEvent CollectionEvent.\r\n   * @private\r\n   */\n  handleLayersAdd_(collectionEvent) {\n    const layer = collectionEvent.element;\n    this.registerLayerListeners_(layer);\n    this.dispatchEvent(new GroupEvent('addlayer', layer));\n    this.changed();\n  }\n\n  /**\r\n   * @param {import(\"../Collection.js\").CollectionEvent<import(\"./Base.js\").default>} collectionEvent CollectionEvent.\r\n   * @private\r\n   */\n  handleLayersRemove_(collectionEvent) {\n    const layer = collectionEvent.element;\n    const key = getUid(layer);\n    this.listenerKeys_[key].forEach(unlistenByKey);\n    delete this.listenerKeys_[key];\n    this.dispatchEvent(new GroupEvent('removelayer', layer));\n    this.changed();\n  }\n\n  /**\r\n   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}\r\n   * in this group.\r\n   * @return {!Collection<import(\"./Base.js\").default>} Collection of\r\n   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.\r\n   * @observable\r\n   * @api\r\n   */\n  getLayers() {\n    return /** @type {!Collection<import(\"./Base.js\").default>} */this.get(Property.LAYERS);\n  }\n\n  /**\r\n   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}\r\n   * in this group.\r\n   * @param {!Collection<import(\"./Base.js\").default>} layers Collection of\r\n   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.\r\n   * @observable\r\n   * @api\r\n   */\n  setLayers(layers) {\n    const collection = this.getLayers();\n    if (collection) {\n      const currentLayers = collection.getArray();\n      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {\n        this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));\n      }\n    }\n    this.set(Property.LAYERS, layers);\n  }\n\n  /**\r\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\r\n   * @override\r\n   */\n  getLayersArray(array) {\n    array = array !== undefined ? array : [];\n    this.getLayers().forEach(function (layer) {\n      layer.getLayersArray(array);\n    });\n    return array;\n  }\n\n  /**\r\n   * Get the layer states list and use this groups z-index as the default\r\n   * for all layers in this and nested groups, if it is unset at this point.\r\n   * If dest is not provided and this group's z-index is undefined\r\n   * 0 is used a the default z-index.\r\n   * @param {Array<import(\"./Layer.js\").State>} [dest] Optional list\r\n   * of layer states (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\r\n   * @override\r\n   */\n  getLayerStatesArray(dest) {\n    const states = dest !== undefined ? dest : [];\n    const pos = states.length;\n    this.getLayers().forEach(function (layer) {\n      layer.getLayerStatesArray(states);\n    });\n    const ownLayerState = this.getLayerState();\n    let defaultZIndex = ownLayerState.zIndex;\n    if (!dest && ownLayerState.zIndex === undefined) {\n      defaultZIndex = 0;\n    }\n    for (let i = pos, ii = states.length; i < ii; i++) {\n      const layerState = states[i];\n      layerState.opacity *= ownLayerState.opacity;\n      layerState.visible = layerState.visible && ownLayerState.visible;\n      layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);\n      layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);\n      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);\n      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);\n      if (ownLayerState.extent !== undefined) {\n        if (layerState.extent !== undefined) {\n          layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);\n        } else {\n          layerState.extent = ownLayerState.extent;\n        }\n      }\n      if (layerState.zIndex === undefined) {\n        layerState.zIndex = defaultZIndex;\n      }\n    }\n    return states;\n  }\n\n  /**\r\n   * @return {import(\"../source/Source.js\").State} Source state.\r\n   * @override\r\n   */\n  getSourceState() {\n    return 'ready';\n  }\n}\nexport default LayerGroup;", "/**\r\n * @module ol/MapEvent\r\n */\nimport Event from './events/Event.js';\n\n/**\r\n * @classdesc\r\n * Events emitted as map events are instances of this type.\r\n * See {@link module:ol/Map~Map} for which events trigger a map event.\r\n */\nclass MapEvent extends Event {\n  /**\r\n   * @param {string} type Event type.\r\n   * @param {import(\"./Map.js\").default} map Map.\r\n   * @param {?import(\"./Map.js\").FrameState} [frameState] Frame state.\r\n   */\n  constructor(type, map, frameState) {\n    super(type);\n\n    /**\r\n     * The map where the event occurred.\r\n     * @type {import(\"./Map.js\").default}\r\n     * @api\r\n     */\n    this.map = map;\n\n    /**\r\n     * The frame state at the time of the event.\r\n     * @type {?import(\"./Map.js\").FrameState}\r\n     * @api\r\n     */\n    this.frameState = frameState !== undefined ? frameState : null;\n  }\n}\nexport default MapEvent;", "/**\r\n * @module ol/MapBrowserEvent\r\n */\nimport MapEvent from './MapEvent.js';\n\n/**\r\n * @classdesc\r\n * Events emitted as map browser events are instances of this type.\r\n * See {@link module:ol/Map~Map} for which events trigger a map browser event.\r\n * @template {UIEvent} EVENT\r\n */\nclass MapBrowserEvent extends MapEvent {\n  /**\r\n   * @param {string} type Event type.\r\n   * @param {import(\"./Map.js\").default} map Map.\r\n   * @param {EVENT} originalEvent Original event.\r\n   * @param {boolean} [dragging] Is the map currently being dragged?\r\n   * @param {import(\"./Map.js\").FrameState} [frameState] Frame state.\r\n   * @param {Array<PointerEvent>} [activePointers] Active pointers.\r\n   */\n  constructor(type, map, originalEvent, dragging, frameState, activePointers) {\n    super(type, map, frameState);\n\n    /**\r\n     * The original browser event.\r\n     * @const\r\n     * @type {EVENT}\r\n     * @api\r\n     */\n    this.originalEvent = originalEvent;\n\n    /**\r\n     * The map pixel relative to the viewport corresponding to the original browser event.\r\n     * @type {?import(\"./pixel.js\").Pixel}\r\n     * @private\r\n     */\n    this.pixel_ = null;\n\n    /**\r\n     * The coordinate in the user projection corresponding to the original browser event.\r\n     * @type {?import(\"./coordinate.js\").Coordinate}\r\n     * @private\r\n     */\n    this.coordinate_ = null;\n\n    /**\r\n     * Indicates if the map is currently being dragged. Only set for\r\n     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.\r\n     *\r\n     * @type {boolean}\r\n     * @api\r\n     */\n    this.dragging = dragging !== undefined ? dragging : false;\n\n    /**\r\n     * @type {Array<PointerEvent>|undefined}\r\n     */\n    this.activePointers = activePointers;\n  }\n\n  /**\r\n   * The map pixel relative to the viewport corresponding to the original event.\r\n   * @type {import(\"./pixel.js\").Pixel}\r\n   * @api\r\n   */\n  get pixel() {\n    if (!this.pixel_) {\n      this.pixel_ = this.map.getEventPixel(this.originalEvent);\n    }\n    return this.pixel_;\n  }\n  set pixel(pixel) {\n    this.pixel_ = pixel;\n  }\n\n  /**\r\n   * The coordinate corresponding to the original browser event.  This will be in the user\r\n   * projection if one is set.  Otherwise it will be in the view projection.\r\n   * @type {import(\"./coordinate.js\").Coordinate}\r\n   * @api\r\n   */\n  get coordinate() {\n    if (!this.coordinate_) {\n      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);\n    }\n    return this.coordinate_;\n  }\n  set coordinate(coordinate) {\n    this.coordinate_ = coordinate;\n  }\n\n  /**\r\n   * Prevents the default browser action.\r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.\r\n   * @api\r\n   * @override\r\n   */\n  preventDefault() {\n    super.preventDefault();\n    if ('preventDefault' in this.originalEvent) {\n      /** @type {UIEvent} */this.originalEvent.preventDefault();\n    }\n  }\n\n  /**\r\n   * Prevents further propagation of the current event.\r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.\r\n   * @api\r\n   * @override\r\n   */\n  stopPropagation() {\n    super.stopPropagation();\n    if ('stopPropagation' in this.originalEvent) {\n      /** @type {UIEvent} */this.originalEvent.stopPropagation();\n    }\n  }\n}\nexport default MapBrowserEvent;", "/**\r\n * @module ol/MapBrowserEventType\r\n */\nimport EventType from './events/EventType.js';\n\n/**\r\n * Constants for event names.\r\n * @enum {string}\r\n */\nexport default {\n  /**\r\n   * A true single click with no dragging and no double click. Note that this\r\n   * event is delayed by 250 ms to ensure that it is not a double click.\r\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick\r\n   * @api\r\n   */\n  SINGLECLICK: 'singleclick',\n  /**\r\n   * A click with no dragging. A double click will fire two of this.\r\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click\r\n   * @api\r\n   */\n  CLICK: EventType.CLICK,\n  /**\r\n   * A true double click, with no dragging.\r\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick\r\n   * @api\r\n   */\n  DBLCLICK: EventType.DBLCLICK,\n  /**\r\n   * Triggered when a pointer is dragged.\r\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag\r\n   * @api\r\n   */\n  POINTERDRAG: 'pointerdrag',\n  /**\r\n   * Triggered when a pointer is moved. Note that on touch devices this is\r\n   * triggered when the map is panned, so is not the same as mousemove.\r\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove\r\n   * @api\r\n   */\n  POINTERMOVE: 'pointermove',\n  POINTERDOWN: 'pointerdown',\n  POINTERUP: 'pointerup',\n  POINTEROVER: 'pointerover',\n  POINTEROUT: 'pointerout',\n  POINTERENTER: 'pointerenter',\n  POINTERLEAVE: 'pointerleave',\n  POINTERCANCEL: 'pointercancel'\n};\n\n/***\r\n * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types\r\n */", "/**\r\n * @module ol/pointer/EventType\r\n */\n\n/**\r\n * Constants for event names.\r\n * @enum {string}\r\n */\nexport default {\n  POINTERMOVE: 'pointermove',\n  POINTERDOWN: 'pointerdown',\n  POINTERUP: 'pointerup',\n  POINTEROVER: 'pointerover',\n  POINTEROUT: 'pointerout',\n  POINTERENTER: 'pointerenter',\n  POINTERLEAVE: 'pointerleave',\n  POINTERCANCEL: 'pointercancel'\n};", "/**\r\n * @module ol/MapBrowserEventHandler\r\n */\n\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport { PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { listen, unlistenByKey } from './events.js';\nclass MapBrowserEventHandler extends Target {\n  /**\r\n   * @param {import(\"./Map.js\").default} map The map with the viewport to listen to events on.\r\n   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\r\n   */\n  constructor(map, moveTolerance) {\n    super(map);\n\n    /**\r\n     * This is the element that we will listen to the real events on.\r\n     * @type {import(\"./Map.js\").default}\r\n     * @private\r\n     */\n    this.map_ = map;\n\n    /**\r\n     * @type {ReturnType<typeof setTimeout>}\r\n     * @private\r\n     */\n    this.clickTimeoutId_;\n\n    /**\r\n     * Emulate dblclick and singleclick. Will be true when only one pointer is active.\r\n     * @type {boolean}\r\n     */\n    this.emulateClicks_ = false;\n\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\n    this.dragging_ = false;\n\n    /**\r\n     * @type {!Array<import(\"./events.js\").EventsKey>}\r\n     * @private\r\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n\n    /**\r\n     * The most recent \"down\" type event (or null if none have occurred).\r\n     * Set on pointerdown.\r\n     * @type {PointerEvent|null}\r\n     * @private\r\n     */\n    this.down_ = null;\n    const element = this.map_.getViewport();\n\n    /**\r\n     * @type {Array<PointerEvent>}\r\n     * @private\r\n     */\n    this.activePointers_ = [];\n\n    /**\r\n     * @type {!Object<number, Event>}\r\n     * @private\r\n     */\n    this.trackedTouches_ = {};\n\n    /**\r\n     * @private\r\n     */\n    this.element_ = element;\n\n    /**\r\n     * @type {?import(\"./events.js\").EventsKey}\r\n     * @private\r\n     */\n    this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, this.handlePointerDown_, this);\n\n    /**\r\n     * @type {PointerEvent}\r\n     * @private\r\n     */\n    this.originalPointerMoveEvent_;\n\n    /**\r\n     * @type {?import(\"./events.js\").EventsKey}\r\n     * @private\r\n     */\n    this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, this.relayMoveEvent_, this);\n\n    /**\r\n     * @private\r\n     */\n    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);\n    this.element_.addEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {\n      passive: false\n    } : false);\n  }\n\n  /**\r\n   * @param {PointerEvent} pointerEvent Pointer\r\n   * event.\r\n   * @private\r\n   */\n  emulateClick_(pointerEvent) {\n    let newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(() => {\n        this.clickTimeoutId_ = undefined;\n        const newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }, 250);\n    }\n  }\n\n  /**\r\n   * Keeps track on how many pointers are currently active.\r\n   *\r\n   * @param {PointerEvent} pointerEvent Pointer\r\n   * event.\r\n   * @private\r\n   */\n  updateActivePointers_(pointerEvent) {\n    const event = pointerEvent;\n    const id = event.pointerId;\n    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[id];\n      for (const pointerId in this.trackedTouches_) {\n        if (this.trackedTouches_[pointerId].target !== event.target) {\n          // Some platforms assign a new pointerId when the target changes.\n          // If this happens, delete one tracked pointer. If there is more\n          // than one tracked pointer for the old target, it will be cleared\n          // by subsequent POINTERUP events from other pointers.\n          delete this.trackedTouches_[pointerId];\n          break;\n        }\n      }\n    } else if (event.type == MapBrowserEventType.POINTERDOWN || event.type == MapBrowserEventType.POINTERMOVE) {\n      this.trackedTouches_[id] = event;\n    }\n    this.activePointers_ = Object.values(this.trackedTouches_);\n  }\n\n  /**\r\n   * @param {PointerEvent} pointerEvent Pointer\r\n   * event.\r\n   * @private\r\n   */\n  handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n    this.dispatchEvent(newEvent);\n\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.preventDefault().\n    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n    if (this.activePointers_.length === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  }\n\n  /**\r\n   * @param {PointerEvent} pointerEvent Pointer\r\n   * event.\r\n   * @return {boolean} If the left mouse button was pressed.\r\n   * @private\r\n   */\n  isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  }\n\n  /**\r\n   * @param {PointerEvent} pointerEvent Pointer\r\n   * event.\r\n   * @private\r\n   */\n  handlePointerDown_(pointerEvent) {\n    this.emulateClicks_ = this.activePointers_.length === 0;\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n    this.dispatchEvent(newEvent);\n    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);\n    Object.defineProperty(this.down_, 'target', {\n      writable: false,\n      value: pointerEvent.target\n    });\n    if (this.dragListenerKeys_.length === 0) {\n      const doc = this.map_.getOwnerDocument();\n      this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n      /* Note that the listener for `pointercancel is set up on\r\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\r\n       * the `pointerup` and `pointermove` listeners.\r\n       *\r\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\r\n       * issues `pointercancel` events, when there was no `touchend` for a\r\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\r\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\r\n       * But `documentPointerEventHandler_` doesn't know about the first\r\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\r\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\r\n       * only registered there.\r\n       */\n      listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n        this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n      }\n    }\n  }\n\n  /**\r\n   * @param {PointerEvent} pointerEvent Pointer\r\n   * event.\r\n   * @private\r\n   */\n  handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.updateActivePointers_(pointerEvent);\n      this.dragging_ = true;\n      const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);\n      this.dispatchEvent(newEvent);\n    }\n  }\n\n  /**\r\n   * Wrap and relay a pointermove event.\r\n   * @param {PointerEvent} pointerEvent Pointer\r\n   * event.\r\n   * @private\r\n   */\n  relayMoveEvent_(pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));\n  }\n\n  /**\r\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\r\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\r\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\r\n   * when an interaction (currently `DragPan` handles the event.\r\n   * @param {TouchEvent} event Event.\r\n   * @private\r\n   */\n  handleTouchMove_(event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events,\n    // when elm-pep is used as pointer events polyfill.\n    const originalEvent = this.originalPointerMoveEvent_;\n    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {\n      event.preventDefault();\n    }\n  }\n\n  /**\r\n   * @param {PointerEvent} pointerEvent Pointer\r\n   * event.\r\n   * @return {boolean} Is moving.\r\n   * @private\r\n   */\n  isMoving_(pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  }\n\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\n  disposeInternal() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    this.element_ = null;\n    super.disposeInternal();\n  }\n}\nexport default MapBrowserEventHandler;", "/**\r\n * @module ol/MapProperty\r\n */\n\n/**\r\n * @enum {string}\r\n */\nexport default {\n  LAYERGROUP: 'layergroup',\n  SIZE: 'size',\n  TARGET: 'target',\n  VIEW: 'view'\n};", "/**\r\n * @module ol/structs/PriorityQueue\r\n */\nimport { assert } from '../asserts.js';\nimport { clear } from '../obj.js';\n\n/**\r\n * @type {number}\r\n */\nexport const DROP = Infinity;\n\n/**\r\n * @classdesc\r\n * Priority queue.\r\n *\r\n * The implementation is inspired from the Closure Library's Heap class and\r\n * Python's heapq module.\r\n *\r\n * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js\r\n * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.\r\n *\r\n * @template T\r\n */\nclass PriorityQueue {\n  /**\r\n   * @param {function(T): number} priorityFunction Priority function.\r\n   * @param {function(T): string} keyFunction Key function.\r\n   */\n  constructor(priorityFunction, keyFunction) {\n    /**\r\n     * @type {function(T): number}\r\n     * @private\r\n     */\n    this.priorityFunction_ = priorityFunction;\n\n    /**\r\n     * @type {function(T): string}\r\n     * @private\r\n     */\n    this.keyFunction_ = keyFunction;\n\n    /**\r\n     * @type {Array<T>}\r\n     * @private\r\n     */\n    this.elements_ = [];\n\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\n    this.priorities_ = [];\n\n    /**\r\n     * @type {!Object<string, boolean>}\r\n     * @private\r\n     */\n    this.queuedElements_ = {};\n  }\n\n  /**\r\n   * FIXME empty description for jsdoc\r\n   */\n  clear() {\n    this.elements_.length = 0;\n    this.priorities_.length = 0;\n    clear(this.queuedElements_);\n  }\n\n  /**\r\n   * Remove and return the highest-priority element. O(log N).\r\n   * @return {T} Element.\r\n   */\n  dequeue() {\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    const element = elements[0];\n    if (elements.length == 1) {\n      elements.length = 0;\n      priorities.length = 0;\n    } else {\n      elements[0] = /** @type {T} */elements.pop();\n      priorities[0] = /** @type {number} */priorities.pop();\n      this.siftUp_(0);\n    }\n    const elementKey = this.keyFunction_(element);\n    delete this.queuedElements_[elementKey];\n    return element;\n  }\n\n  /**\r\n   * Enqueue an element. O(log N).\r\n   * @param {T} element Element.\r\n   * @return {boolean} The element was added to the queue.\r\n   */\n  enqueue(element) {\n    assert(!(this.keyFunction_(element) in this.queuedElements_), 'Tried to enqueue an `element` that was already added to the queue');\n    const priority = this.priorityFunction_(element);\n    if (priority != DROP) {\n      this.elements_.push(element);\n      this.priorities_.push(priority);\n      this.queuedElements_[this.keyFunction_(element)] = true;\n      this.siftDown_(0, this.elements_.length - 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\r\n   * @return {number} Count.\r\n   */\n  getCount() {\n    return this.elements_.length;\n  }\n\n  /**\r\n   * Gets the index of the left child of the node at the given index.\r\n   * @param {number} index The index of the node to get the left child for.\r\n   * @return {number} The index of the left child.\r\n   * @private\r\n   */\n  getLeftChildIndex_(index) {\n    return index * 2 + 1;\n  }\n\n  /**\r\n   * Gets the index of the right child of the node at the given index.\r\n   * @param {number} index The index of the node to get the right child for.\r\n   * @return {number} The index of the right child.\r\n   * @private\r\n   */\n  getRightChildIndex_(index) {\n    return index * 2 + 2;\n  }\n\n  /**\r\n   * Gets the index of the parent of the node at the given index.\r\n   * @param {number} index The index of the node to get the parent for.\r\n   * @return {number} The index of the parent.\r\n   * @private\r\n   */\n  getParentIndex_(index) {\n    return index - 1 >> 1;\n  }\n\n  /**\r\n   * Make this a heap. O(N).\r\n   * @private\r\n   */\n  heapify_() {\n    let i;\n    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {\n      this.siftUp_(i);\n    }\n  }\n\n  /**\r\n   * @return {boolean} Is empty.\r\n   */\n  isEmpty() {\n    return this.elements_.length === 0;\n  }\n\n  /**\r\n   * @param {string} key Key.\r\n   * @return {boolean} Is key queued.\r\n   */\n  isKeyQueued(key) {\n    return key in this.queuedElements_;\n  }\n\n  /**\r\n   * @param {T} element Element.\r\n   * @return {boolean} Is queued.\r\n   */\n  isQueued(element) {\n    return this.isKeyQueued(this.keyFunction_(element));\n  }\n\n  /**\r\n   * @param {number} index The index of the node to move down.\r\n   * @private\r\n   */\n  siftUp_(index) {\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    const count = elements.length;\n    const element = elements[index];\n    const priority = priorities[index];\n    const startIndex = index;\n    while (index < count >> 1) {\n      const lIndex = this.getLeftChildIndex_(index);\n      const rIndex = this.getRightChildIndex_(index);\n      const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;\n      elements[index] = elements[smallerChildIndex];\n      priorities[index] = priorities[smallerChildIndex];\n      index = smallerChildIndex;\n    }\n    elements[index] = element;\n    priorities[index] = priority;\n    this.siftDown_(startIndex, index);\n  }\n\n  /**\r\n   * @param {number} startIndex The index of the root.\r\n   * @param {number} index The index of the node to move up.\r\n   * @private\r\n   */\n  siftDown_(startIndex, index) {\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    const element = elements[index];\n    const priority = priorities[index];\n    while (index > startIndex) {\n      const parentIndex = this.getParentIndex_(index);\n      if (priorities[parentIndex] > priority) {\n        elements[index] = elements[parentIndex];\n        priorities[index] = priorities[parentIndex];\n        index = parentIndex;\n      } else {\n        break;\n      }\n    }\n    elements[index] = element;\n    priorities[index] = priority;\n  }\n\n  /**\r\n   * FIXME empty description for jsdoc\r\n   */\n  reprioritize() {\n    const priorityFunction = this.priorityFunction_;\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    let index = 0;\n    const n = elements.length;\n    let element, i, priority;\n    for (i = 0; i < n; ++i) {\n      element = elements[i];\n      priority = priorityFunction(element);\n      if (priority == DROP) {\n        delete this.queuedElements_[this.keyFunction_(element)];\n      } else {\n        priorities[index] = priority;\n        elements[index++] = element;\n      }\n    }\n    elements.length = index;\n    priorities.length = index;\n    this.heapify_();\n  }\n}\nexport default PriorityQueue;", "/**\r\n * @module ol/TileQueue\r\n */\nimport EventType from './events/EventType.js';\nimport PriorityQueue, { DROP } from './structs/PriorityQueue.js';\nimport TileState from './TileState.js';\n\n/**\r\n * @typedef {function(import(\"./Tile.js\").default, string, import(\"./coordinate.js\").Coordinate, number): number} PriorityFunction\r\n */\n\nclass TileQueue extends PriorityQueue {\n  /**\r\n   * @param {PriorityFunction} tilePriorityFunction Tile priority function.\r\n   * @param {function(): ?} tileChangeCallback Function called on each tile change event.\r\n   */\n  constructor(tilePriorityFunction, tileChangeCallback) {\n    super(\n    /**\r\n     * @param {Array} element Element.\r\n     * @return {number} Priority.\r\n     */\n    function (element) {\n      return tilePriorityFunction.apply(null, element);\n    },\n    /**\r\n     * @param {Array} element Element.\r\n     * @return {string} Key.\r\n     */\n    function (element) {\n      return /** @type {import(\"./Tile.js\").default} */element[0].getKey();\n    });\n\n    /** @private */\n    this.boundHandleTileChange_ = this.handleTileChange.bind(this);\n\n    /**\r\n     * @private\r\n     * @type {function(): ?}\r\n     */\n    this.tileChangeCallback_ = tileChangeCallback;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.tilesLoading_ = 0;\n\n    /**\r\n     * @private\r\n     * @type {!Object<string,boolean>}\r\n     */\n    this.tilesLoadingKeys_ = {};\n  }\n\n  /**\r\n   * @param {Array} element Element.\r\n   * @return {boolean} The element was added to the queue.\r\n   * @override\r\n   */\n  enqueue(element) {\n    const added = super.enqueue(element);\n    if (added) {\n      const tile = element[0];\n      tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n    }\n    return added;\n  }\n\n  /**\r\n   * @return {number} Number of tiles loading.\r\n   */\n  getTilesLoading() {\n    return this.tilesLoading_;\n  }\n\n  /**\r\n   * @param {import(\"./events/Event.js\").default} event Event.\r\n   * @protected\r\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"./Tile.js\").default} */event.target;\n    const state = tile.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {\n      if (state !== TileState.ERROR) {\n        tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n      }\n      const tileKey = tile.getKey();\n      if (tileKey in this.tilesLoadingKeys_) {\n        delete this.tilesLoadingKeys_[tileKey];\n        --this.tilesLoading_;\n      }\n      this.tileChangeCallback_();\n    }\n  }\n\n  /**\r\n   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\r\n   * @param {number} maxNewLoads Maximum number of new tiles to load.\r\n   */\n  loadMoreTiles(maxTotalLoading, maxNewLoads) {\n    let newLoads = 0;\n    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {\n      /**\r\n       * @type {import(\"./Tile.js\").default}\r\n       */\n      const tile = this.dequeue()[0];\n      const tileKey = tile.getKey();\n      const state = tile.getState();\n      if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n        this.tilesLoadingKeys_[tileKey] = true;\n        ++this.tilesLoading_;\n        ++newLoads;\n        tile.load();\n      }\n    }\n  }\n}\nexport default TileQueue;\n\n/**\r\n * @param {import('./Map.js').FrameState} frameState Frame state.\r\n * @param {import(\"./Tile.js\").default} tile Tile.\r\n * @param {string} tileSourceKey Tile source key.\r\n * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\r\n * @param {number} tileResolution Tile resolution.\r\n * @return {number} Tile priority.\r\n */\nexport function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {\n  // Filter out tiles at higher zoom levels than the current zoom level, or that\n  // are outside the visible extent.\n  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n    return DROP;\n  }\n  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n    return DROP;\n  }\n  // Prioritize the highest zoom level tiles closest to the focus.\n  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n  // Within a zoom level, tiles are prioritized by the distance in pixels between\n  // the center of the tile and the center of the viewport.  The factor of 65536\n  // means that the prioritization should behave as desired for tiles up to\n  // 65536 * Math.log(2) = 45426 pixels from the focus.\n  const center = frameState.viewState.center;\n  const deltaX = tileCenter[0] - center[0];\n  const deltaY = tileCenter[1] - center[1];\n  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n}", "/**\r\n * @module ol/control/Control\r\n */\nimport BaseObject from '../Object.js';\nimport MapEventType from '../MapEventType.js';\nimport { VOID } from '../functions.js';\nimport { listen, unlistenByKey } from '../events.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {HTMLElement} [element] The element is the control's\r\n * container element. This only needs to be specified if you're developing\r\n * a custom control.\r\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when\r\n * the control should be re-rendered. This is called in a `requestAnimationFrame`\r\n * callback.\r\n * @property {HTMLElement|string} [target] Specify a target if you want\r\n * the control to be rendered outside of the map's viewport.\r\n */\n\n/**\r\n * @classdesc\r\n * A control is a visible widget with a DOM element in a fixed position on the\r\n * screen. They can involve user input (buttons), or be informational only;\r\n * the position is determined using CSS. By default these are placed in the\r\n * container with CSS class name `ol-overlaycontainer-stopevent`, but can use\r\n * any outside DOM element.\r\n *\r\n * This is the base class for controls. You can use it for simple custom\r\n * controls by creating the element with listeners, creating an instance:\r\n * ```js\r\n * const myControl = new Control({element: myElement});\r\n * ```\r\n * and then adding this to the map.\r\n *\r\n * The main advantage of having this as a control rather than a simple separate\r\n * DOM element is that preventing propagation is handled for you. Controls\r\n * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.\r\n *\r\n * You can also extend this base for your own control class. See\r\n * examples/custom-controls for an example of how to do this.\r\n *\r\n * @api\r\n */\nclass Control extends BaseObject {\n  /**\r\n   * @param {Options} options Control options.\r\n   */\n  constructor(options) {\n    super();\n    const element = options.element;\n    if (element && !options.target && !element.style.pointerEvents) {\n      element.style.pointerEvents = 'auto';\n    }\n\n    /**\r\n     * @protected\r\n     * @type {HTMLElement}\r\n     */\n    this.element = element ? element : null;\n\n    /**\r\n     * @private\r\n     * @type {HTMLElement}\r\n     */\n    this.target_ = null;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../Map.js\").default|null}\r\n     */\n    this.map_ = null;\n\n    /**\r\n     * @protected\r\n     * @type {!Array<import(\"../events.js\").EventsKey>}\r\n     */\n    this.listenerKeys = [];\n    if (options.render) {\n      this.render = options.render;\n    }\n    if (options.target) {\n      this.setTarget(options.target);\n    }\n  }\n\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\n  disposeInternal() {\n    this.element?.remove();\n    super.disposeInternal();\n  }\n\n  /**\r\n   * Get the map associated with this control.\r\n   * @return {import(\"../Map.js\").default|null} Map.\r\n   * @api\r\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\r\n   * Remove the control from its current map and attach it to the new map.\r\n   * Pass `null` to just remove the control from the current map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../Map.js\").default|null} map Map.\r\n   * @api\r\n   */\n  setMap(map) {\n    if (this.map_) {\n      this.element?.remove();\n    }\n    for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {\n      unlistenByKey(this.listenerKeys[i]);\n    }\n    this.listenerKeys.length = 0;\n    this.map_ = map;\n    if (map) {\n      const target = this.target_ ?? map.getOverlayContainerStopEvent();\n      if (this.element) {\n        target.appendChild(this.element);\n      }\n      if (this.render !== VOID) {\n        this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));\n      }\n      map.render();\n    }\n  }\n\n  /**\r\n   * Renders the control.\r\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\r\n   * @api\r\n   */\n  render(mapEvent) {}\n\n  /**\r\n   * This function is used to set a target element for the control. It has no\r\n   * effect if it is called after the control has been added to the map (i.e.\r\n   * after `setMap` is called on the control). If no `target` is set in the\r\n   * options passed to the control constructor and if `setTarget` is not called\r\n   * then the control is added to the map's overlay container.\r\n   * @param {HTMLElement|string} target Target.\r\n   * @api\r\n   */\n  setTarget(target) {\n    this.target_ = typeof target === 'string' ? document.getElementById(target) : target;\n  }\n}\nexport default Control;", "/**\r\n * @module ol/control/Attribution\r\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport { CLASS_COLLAPSED, CLASS_CONTROL, CLASS_UNSELECTABLE } from '../css.js';\nimport { equals } from '../array.js';\nimport { removeChildren, replaceNode } from '../dom.js';\nimport { toPromise } from '../functions.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-attribution'] CSS class name.\r\n * @property {HTMLElement|string} [target] Specify a target if you\r\n * want the control to be rendered outside of the map's\r\n * viewport.\r\n * @property {boolean} [collapsible] Specify if attributions can\r\n * be collapsed. If not specified, sources control this behavior with their\r\n * `attributionsCollapsible` setting.\r\n * @property {boolean} [collapsed=true] Specify if attributions should\r\n * be collapsed at startup.\r\n * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.\r\n * @property {string|HTMLElement} [label='i'] Text label to use for the\r\n * collapsed attributions button.\r\n * Instead of text, also an element (e.g. a `span` element) can be used.\r\n * @property {string} [expandClassName=className + '-expand'] CSS class name for the\r\n * collapsed attributions button.\r\n * @property {string|HTMLElement} [collapseLabel='›'] Text label to use\r\n * for the expanded attributions button.\r\n * Instead of text, also an element (e.g. a `span` element) can be used.\r\n * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the\r\n * expanded attributions button.\r\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when\r\n * the control should be re-rendered. This is called in a `requestAnimationFrame`\r\n * callback.\r\n * @property {string|Array<string>|undefined} [attributions] Optional attribution(s) that will always be\r\n * displayed regardless of the layers rendered\r\n */\n\n/**\r\n * @classdesc\r\n * Control to show all the attributions associated with the layer sources\r\n * in the map. This control is one of the default controls included in maps.\r\n * By default it will show in the bottom right portion of the map, but this can\r\n * be changed by using a css selector for `.ol-attribution`.\r\n *\r\n * @api\r\n */\nclass Attribution extends Control {\n  /**\r\n   * @param {Options} [options] Attribution options.\r\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super({\n      element: document.createElement('div'),\n      render: options.render,\n      target: options.target\n    });\n\n    /**\r\n     * @private\r\n     * @type {HTMLElement}\r\n     */\n    this.ulElement_ = document.createElement('ul');\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.userCollapsed_ = this.collapsed_;\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.overrideCollapsible_ = options.collapsible !== undefined;\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;\n    if (!this.collapsible_) {\n      this.collapsed_ = false;\n    }\n\n    /**\r\n     * @private\r\n     * @type {string | Array<string> | undefined}\r\n     */\n    this.attributions_ = options.attributions;\n    const className = options.className !== undefined ? options.className : 'ol-attribution';\n    const tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';\n    const expandClassName = options.expandClassName !== undefined ? options.expandClassName : className + '-expand';\n    const collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\\u203A';\n    const collapseClassName = options.collapseClassName !== undefined ? options.collapseClassName : className + '-collapse';\n    if (typeof collapseLabel === 'string') {\n      /**\r\n       * @private\r\n       * @type {HTMLElement}\r\n       */\n      this.collapseLabel_ = document.createElement('span');\n      this.collapseLabel_.textContent = collapseLabel;\n      this.collapseLabel_.className = collapseClassName;\n    } else {\n      this.collapseLabel_ = collapseLabel;\n    }\n    const label = options.label !== undefined ? options.label : 'i';\n    if (typeof label === 'string') {\n      /**\r\n       * @private\r\n       * @type {HTMLElement}\r\n       */\n      this.label_ = document.createElement('span');\n      this.label_.textContent = label;\n      this.label_.className = expandClassName;\n    } else {\n      this.label_ = label;\n    }\n    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;\n\n    /**\r\n     * @private\r\n     * @type {HTMLElement}\r\n     */\n    this.toggleButton_ = document.createElement('button');\n    this.toggleButton_.setAttribute('type', 'button');\n    this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));\n    this.toggleButton_.title = tipLabel;\n    this.toggleButton_.appendChild(activeLabel);\n    this.toggleButton_.addEventListener(EventType.CLICK, this.handleClick_.bind(this), false);\n    const cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') + (this.collapsible_ ? '' : ' ol-uncollapsible');\n    const element = this.element;\n    element.className = cssClasses;\n    element.appendChild(this.toggleButton_);\n    element.appendChild(this.ulElement_);\n\n    /**\r\n     * A list of currently rendered resolutions.\r\n     * @type {Array<string>}\r\n     * @private\r\n     */\n    this.renderedAttributions_ = [];\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.renderedVisible_ = true;\n  }\n\n  /**\r\n   * Collect a list of visible attributions and set the collapsible state.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @return {Array<string>} Attributions.\r\n   * @private\r\n   */\n  collectSourceAttributions_(frameState) {\n    const layers = this.getMap().getAllLayers();\n    const visibleAttributions = new Set(layers.flatMap(layer => layer.getAttributions(frameState)));\n    if (this.attributions_ !== undefined) {\n      Array.isArray(this.attributions_) ? this.attributions_.forEach(item => visibleAttributions.add(item)) : visibleAttributions.add(this.attributions_);\n    }\n    if (!this.overrideCollapsible_) {\n      const collapsible = !layers.some(layer => layer.getSource()?.getAttributionsCollapsible() === false);\n      this.setCollapsible(collapsible);\n    }\n    return Array.from(visibleAttributions);\n  }\n\n  /**\r\n   * @private\r\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\n  async updateElement_(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n    const attributions = await Promise.all(this.collectSourceAttributions_(frameState).map(attribution => toPromise(() => attribution)));\n    const visible = attributions.length > 0;\n    if (this.renderedVisible_ != visible) {\n      this.element.style.display = visible ? '' : 'none';\n      this.renderedVisible_ = visible;\n    }\n    if (equals(attributions, this.renderedAttributions_)) {\n      return;\n    }\n    removeChildren(this.ulElement_);\n\n    // append the attributions\n    for (let i = 0, ii = attributions.length; i < ii; ++i) {\n      const element = document.createElement('li');\n      element.innerHTML = attributions[i];\n      this.ulElement_.appendChild(element);\n    }\n    this.renderedAttributions_ = attributions;\n  }\n\n  /**\r\n   * @param {MouseEvent} event The event to handle\r\n   * @private\r\n   */\n  handleClick_(event) {\n    event.preventDefault();\n    this.handleToggle_();\n    this.userCollapsed_ = this.collapsed_;\n  }\n\n  /**\r\n   * @private\r\n   */\n  handleToggle_() {\n    this.element.classList.toggle(CLASS_COLLAPSED);\n    if (this.collapsed_) {\n      replaceNode(this.collapseLabel_, this.label_);\n    } else {\n      replaceNode(this.label_, this.collapseLabel_);\n    }\n    this.collapsed_ = !this.collapsed_;\n    this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));\n  }\n\n  /**\r\n   * Return `true` if the attribution is collapsible, `false` otherwise.\r\n   * @return {boolean} True if the widget is collapsible.\r\n   * @api\r\n   */\n  getCollapsible() {\n    return this.collapsible_;\n  }\n\n  /**\r\n   * Set whether the attribution should be collapsible.\r\n   * @param {boolean} collapsible True if the widget is collapsible.\r\n   * @api\r\n   */\n  setCollapsible(collapsible) {\n    if (this.collapsible_ === collapsible) {\n      return;\n    }\n    this.collapsible_ = collapsible;\n    this.element.classList.toggle('ol-uncollapsible');\n    if (this.userCollapsed_) {\n      this.handleToggle_();\n    }\n  }\n\n  /**\r\n   * Collapse or expand the attribution according to the passed parameter. Will\r\n   * not do anything if the attribution isn't collapsible or if the current\r\n   * collapsed state is already the one requested.\r\n   * @param {boolean} collapsed True if the widget is collapsed.\r\n   * @api\r\n   */\n  setCollapsed(collapsed) {\n    this.userCollapsed_ = collapsed;\n    if (!this.collapsible_ || this.collapsed_ === collapsed) {\n      return;\n    }\n    this.handleToggle_();\n  }\n\n  /**\r\n   * Return `true` when the attribution is currently collapsed or `false`\r\n   * otherwise.\r\n   * @return {boolean} True if the widget is collapsed.\r\n   * @api\r\n   */\n  getCollapsed() {\n    return this.collapsed_;\n  }\n\n  /**\r\n   * Update the attribution element.\r\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\r\n   * @override\r\n   */\n  render(mapEvent) {\n    this.updateElement_(mapEvent.frameState);\n  }\n}\nexport default Attribution;", "/**\r\n * @module ol/control/Rotate\r\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport { CLASS_CONTROL, CLASS_HIDDEN, CLASS_UNSELECTABLE } from '../css.js';\nimport { easeOut } from '../easing.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-rotate'] CSS class name.\r\n * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.\r\n * Instead of text, also an element (e.g. a `span` element) can be used.\r\n * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.\r\n * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.\r\n * @property {number} [duration=250] Animation duration in milliseconds.\r\n * @property {boolean} [autoHide=true] Hide the control when rotation is 0.\r\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the control should\r\n * be re-rendered. This is called in a `requestAnimationFrame` callback.\r\n * @property {function():void} [resetNorth] Function called when the control is clicked.\r\n * This will override the default `resetNorth`.\r\n * @property {HTMLElement|string} [target] Specify a target if you want the control to be\r\n * rendered outside of the map's viewport.\r\n */\n\n/**\r\n * @classdesc\r\n * A button control to reset rotation to 0.\r\n * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css\r\n * selector is added to the button when the rotation is 0.\r\n *\r\n * @api\r\n */\nclass Rotate extends Control {\n  /**\r\n   * @param {Options} [options] Rotate options.\r\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super({\n      element: document.createElement('div'),\n      render: options.render,\n      target: options.target\n    });\n    const className = options.className !== undefined ? options.className : 'ol-rotate';\n    const label = options.label !== undefined ? options.label : '\\u21E7';\n    const compassClassName = options.compassClassName !== undefined ? options.compassClassName : 'ol-compass';\n\n    /**\r\n     * @type {HTMLElement}\r\n     * @private\r\n     */\n    this.label_ = null;\n    if (typeof label === 'string') {\n      this.label_ = document.createElement('span');\n      this.label_.className = compassClassName;\n      this.label_.textContent = label;\n    } else {\n      this.label_ = label;\n      this.label_.classList.add(compassClassName);\n    }\n    const tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';\n    const button = document.createElement('button');\n    button.className = className + '-reset';\n    button.setAttribute('type', 'button');\n    button.title = tipLabel;\n    button.appendChild(this.label_);\n    button.addEventListener(EventType.CLICK, this.handleClick_.bind(this), false);\n    const cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n    const element = this.element;\n    element.className = cssClasses;\n    element.appendChild(button);\n\n    /**\r\n     * @private\r\n     */\n    this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;\n\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\n    this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;\n\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\n    this.rotation_ = undefined;\n    if (this.autoHide_) {\n      this.element.classList.add(CLASS_HIDDEN);\n    }\n  }\n\n  /**\r\n   * @param {MouseEvent} event The event to handle\r\n   * @private\r\n   */\n  handleClick_(event) {\n    event.preventDefault();\n    if (this.callResetNorth_ !== undefined) {\n      this.callResetNorth_();\n    } else {\n      this.resetNorth_();\n    }\n  }\n\n  /**\r\n   * @private\r\n   */\n  resetNorth_() {\n    const map = this.getMap();\n    const view = map.getView();\n    if (!view) {\n      // the map does not have a view, so we can't act\n      // upon it\n      return;\n    }\n    const rotation = view.getRotation();\n    if (rotation !== undefined) {\n      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {\n        view.animate({\n          rotation: 0,\n          duration: this.duration_,\n          easing: easeOut\n        });\n      } else {\n        view.setRotation(0);\n      }\n    }\n  }\n\n  /**\r\n   * Update the rotate control element.\r\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\r\n   * @override\r\n   */\n  render(mapEvent) {\n    const frameState = mapEvent.frameState;\n    if (!frameState) {\n      return;\n    }\n    const rotation = frameState.viewState.rotation;\n    if (rotation != this.rotation_) {\n      const transform = 'rotate(' + rotation + 'rad)';\n      if (this.autoHide_) {\n        const contains = this.element.classList.contains(CLASS_HIDDEN);\n        if (!contains && rotation === 0) {\n          this.element.classList.add(CLASS_HIDDEN);\n        } else if (contains && rotation !== 0) {\n          this.element.classList.remove(CLASS_HIDDEN);\n        }\n      }\n      this.label_.style.transform = transform;\n    }\n    this.rotation_ = rotation;\n  }\n}\nexport default Rotate;", "/**\r\n * @module ol/control/Zoom\r\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport { CLASS_CONTROL, CLASS_UNSELECTABLE } from '../css.js';\nimport { easeOut } from '../easing.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [duration=250] Animation duration in milliseconds.\r\n * @property {string} [className='ol-zoom'] CSS class name.\r\n * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.\r\n * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.\r\n * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in\r\n * button. Instead of text, also an element (e.g. a `span` element) can be used.\r\n * @property {string|HTMLElement} [zoomOutLabel='–'] Text label to use for the zoom-out button.\r\n * Instead of text, also an element (e.g. a `span` element) can be used.\r\n * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.\r\n * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.\r\n * @property {number} [delta=1] The zoom delta applied on each click.\r\n * @property {HTMLElement|string} [target] Specify a target if you want the control to be\r\n * rendered outside of the map's viewport.\r\n */\n\n/**\r\n * @classdesc\r\n * A control with 2 buttons, one for zoom in and one for zoom out.\r\n * This control is one of the default controls of a map. To style this control\r\n * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.\r\n *\r\n * @api\r\n */\nclass Zoom extends Control {\n  /**\r\n   * @param {Options} [options] Zoom options.\r\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super({\n      element: document.createElement('div'),\n      target: options.target\n    });\n    const className = options.className !== undefined ? options.className : 'ol-zoom';\n    const delta = options.delta !== undefined ? options.delta : 1;\n    const zoomInClassName = options.zoomInClassName !== undefined ? options.zoomInClassName : className + '-in';\n    const zoomOutClassName = options.zoomOutClassName !== undefined ? options.zoomOutClassName : className + '-out';\n    const zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';\n    const zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\\u2013';\n    const zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';\n    const zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';\n    const inElement = document.createElement('button');\n    inElement.className = zoomInClassName;\n    inElement.setAttribute('type', 'button');\n    inElement.title = zoomInTipLabel;\n    inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);\n    inElement.addEventListener(EventType.CLICK, this.handleClick_.bind(this, delta), false);\n    const outElement = document.createElement('button');\n    outElement.className = zoomOutClassName;\n    outElement.setAttribute('type', 'button');\n    outElement.title = zoomOutTipLabel;\n    outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);\n    outElement.addEventListener(EventType.CLICK, this.handleClick_.bind(this, -delta), false);\n    const cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n    const element = this.element;\n    element.className = cssClasses;\n    element.appendChild(inElement);\n    element.appendChild(outElement);\n\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\r\n   * @param {number} delta Zoom delta.\r\n   * @param {MouseEvent} event The event to handle\r\n   * @private\r\n   */\n  handleClick_(delta, event) {\n    event.preventDefault();\n    this.zoomByDelta_(delta);\n  }\n\n  /**\r\n   * @param {number} delta Zoom delta.\r\n   * @private\r\n   */\n  zoomByDelta_(delta) {\n    const map = this.getMap();\n    const view = map.getView();\n    if (!view) {\n      // the map does not have a view, so we can't act\n      // upon it\n      return;\n    }\n    const currentZoom = view.getZoom();\n    if (currentZoom !== undefined) {\n      const newZoom = view.getConstrainedZoom(currentZoom + delta);\n      if (this.duration_ > 0) {\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        view.animate({\n          zoom: newZoom,\n          duration: this.duration_,\n          easing: easeOut\n        });\n      } else {\n        view.setZoom(newZoom);\n      }\n    }\n  }\n}\nexport default Zoom;", "/**\r\n * @module ol/control/defaults\r\n */\nimport Attribution from './Attribution.js';\nimport Collection from '../Collection.js';\nimport Rotate from './Rotate.js';\nimport Zoom from './Zoom.js';\n\n/**\r\n * @typedef {Object} DefaultsOptions\r\n * @property {boolean} [attribution=true] Include\r\n * {@link module:ol/control/Attribution~Attribution}.\r\n * @property {import(\"./Attribution.js\").Options} [attributionOptions]\r\n * Options for {@link module:ol/control/Attribution~Attribution}.\r\n * @property {boolean} [rotate=true] Include\r\n * {@link module:ol/control/Rotate~Rotate}.\r\n * @property {import(\"./Rotate.js\").Options} [rotateOptions] Options\r\n * for {@link module:ol/control/Rotate~Rotate}.\r\n * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.\r\n * @property {import(\"./Zoom.js\").Options} [zoomOptions] Options for\r\n * {@link module:ol/control/Zoom~Zoom}.\r\n */\n\n/**\r\n * Set of controls included in maps by default. Unless configured otherwise,\r\n * this returns a collection containing an instance of each of the following\r\n * controls:\r\n * * {@link module:ol/control/Zoom~Zoom}\r\n * * {@link module:ol/control/Rotate~Rotate}\r\n * * {@link module:ol/control/Attribution~Attribution}\r\n *\r\n * @param {DefaultsOptions} [options] Options for the default controls.\r\n * @return {Collection<import(\"./Control.js\").default>} A collection of controls\r\n * to be used with the {@link module:ol/Map~Map} constructor's `controls` option.\r\n * @api\r\n */\nexport function defaults(options) {\n  options = options ? options : {};\n\n  /** @type {Collection<import(\"./Control.js\").default>} */\n  const controls = new Collection();\n  const zoomControl = options.zoom !== undefined ? options.zoom : true;\n  if (zoomControl) {\n    controls.push(new Zoom(options.zoomOptions));\n  }\n  const rotateControl = options.rotate !== undefined ? options.rotate : true;\n  if (rotateControl) {\n    controls.push(new Rotate(options.rotateOptions));\n  }\n  const attributionControl = options.attribution !== undefined ? options.attribution : true;\n  if (attributionControl) {\n    controls.push(new Attribution(options.attributionOptions));\n  }\n  return controls;\n}", "/**\r\n * @module ol/interaction/Property\r\n */\n\n/**\r\n * @enum {string}\r\n */\nexport default {\n  ACTIVE: 'active'\n};", "/**\r\n * @module ol/interaction/Interaction\r\n */\nimport BaseObject from '../Object.js';\nimport InteractionProperty from './Property.js';\nimport { easeOut, linear } from '../easing.js';\n\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active', Return>} InteractionOnSignature\r\n */\n\n/**\r\n * Object literal with config options for interactions.\r\n * @typedef {Object} InteractionOptions\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleEvent]\r\n * Method called by the map to notify the interaction that a browser event was\r\n * dispatched to the map. If the function returns a falsy value, propagation of\r\n * the event to other interactions in the map's interactions chain will be\r\n * prevented (this includes functions with no explicit return). The interactions\r\n * are traversed in reverse order of the interactions collection of the map.\r\n */\n\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * User actions that change the state of the map. Some are similar to controls,\r\n * but are not associated with a DOM element.\r\n * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is\r\n * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered\r\n * by a keyboard event not a button element event.\r\n * Although interactions do not have a DOM element, some of them do render\r\n * vectors and so are visible on the screen.\r\n * @api\r\n */\nclass Interaction extends BaseObject {\n  /**\r\n   * @param {InteractionOptions} [options] Options.\r\n   */\n  constructor(options) {\n    super();\n\n    /***\r\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\r\n     */\n    this.on;\n\n    /***\r\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\r\n     */\n    this.once;\n\n    /***\r\n     * @type {InteractionOnSignature<void>}\r\n     */\n    this.un;\n    if (options && options.handleEvent) {\n      this.handleEvent = options.handleEvent;\n    }\n\n    /**\r\n     * @private\r\n     * @type {import(\"../Map.js\").default|null}\r\n     */\n    this.map_ = null;\n    this.setActive(true);\n  }\n\n  /**\r\n   * Return whether the interaction is currently active.\r\n   * @return {boolean} `true` if the interaction is active, `false` otherwise.\r\n   * @observable\r\n   * @api\r\n   */\n  getActive() {\n    return /** @type {boolean} */this.get(InteractionProperty.ACTIVE);\n  }\n\n  /**\r\n   * Get the map associated with this interaction.\r\n   * @return {import(\"../Map.js\").default|null} Map.\r\n   * @api\r\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @api\r\n   */\n  handleEvent(mapBrowserEvent) {\n    return true;\n  }\n\n  /**\r\n   * Activate or deactivate the interaction.\r\n   * @param {boolean} active Active.\r\n   * @observable\r\n   * @api\r\n   */\n  setActive(active) {\n    this.set(InteractionProperty.ACTIVE, active);\n  }\n\n  /**\r\n   * Remove the interaction from its current map and attach it to the new map.\r\n   * Subclasses may set up event handlers to get notified about changes to\r\n   * the map here.\r\n   * @param {import(\"../Map.js\").default|null} map Map.\r\n   */\n  setMap(map) {\n    this.map_ = map;\n  }\n}\n\n/**\r\n * @param {import(\"../View.js\").default} view View.\r\n * @param {import(\"../coordinate.js\").Coordinate} delta Delta.\r\n * @param {number} [duration] Duration.\r\n */\nexport function pan(view, delta, duration) {\n  const currentCenter = view.getCenterInternal();\n  if (currentCenter) {\n    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];\n    view.animateInternal({\n      duration: duration !== undefined ? duration : 250,\n      easing: linear,\n      center: view.getConstrainedCenter(center)\n    });\n  }\n}\n\n/**\r\n * @param {import(\"../View.js\").default} view View.\r\n * @param {number} delta Delta from previous zoom level.\r\n * @param {import(\"../coordinate.js\").Coordinate} [anchor] Anchor coordinate in the user projection.\r\n * @param {number} [duration] Duration.\r\n */\nexport function zoomByDelta(view, delta, anchor, duration) {\n  const currentZoom = view.getZoom();\n  if (currentZoom === undefined) {\n    return;\n  }\n  const newZoom = view.getConstrainedZoom(currentZoom + delta);\n  const newResolution = view.getResolutionForZoom(newZoom);\n  if (view.getAnimating()) {\n    view.cancelAnimations();\n  }\n  view.animate({\n    resolution: newResolution,\n    anchor: anchor,\n    duration: duration !== undefined ? duration : 250,\n    easing: easeOut\n  });\n}\nexport default Interaction;", "/**\r\n * @module ol/interaction/DoubleClickZoom\r\n */\nimport Interaction, { zoomByDelta } from './Interaction.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [duration=250] Animation duration in milliseconds.\r\n * @property {number} [delta=1] The zoom delta applied on each double click.\r\n */\n\n/**\r\n * @classdesc\r\n * Allows the user to zoom by double-clicking on the map.\r\n * @api\r\n */\nclass DoubleClickZoom extends Interaction {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a\r\n   * doubleclick) and eventually zooms the map.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @override\r\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {\n      const browserEvent = /** @type {MouseEvent} */\n      mapBrowserEvent.originalEvent;\n      const map = mapBrowserEvent.map;\n      const anchor = mapBrowserEvent.coordinate;\n      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;\n      const view = map.getView();\n      zoomByDelta(view, delta, anchor, this.duration_);\n      browserEvent.preventDefault();\n      stopEvent = true;\n    }\n    return !stopEvent;\n  }\n}\nexport default DoubleClickZoom;", "/**\r\n * @module ol/interaction/Pointer\r\n */\nimport Interaction from './Interaction.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleDownEvent]\r\n * Function handling \"down\" events. If the function returns `true` then a drag\r\n * sequence is started.\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleDragEvent]\r\n * Function handling \"drag\" events. This function is called on \"move\" events\r\n * during a drag sequence.\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleEvent]\r\n * Method called by the map to notify the interaction that a browser event was\r\n * dispatched to the map. The function may return `false` to prevent the\r\n * propagation of the event to other interactions in the map's interactions\r\n * chain.\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleMoveEvent]\r\n * Function handling \"move\" events. This function is called on \"move\" events.\r\n * This functions is also called during a drag sequence, so during a drag\r\n * sequence both the `handleDragEvent` function and this function are called.\r\n * If `handleDownEvent` is defined and it returns true this function will not\r\n * be called during a drag sequence.\r\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleUpEvent]\r\n *  Function handling \"up\" events. If the function returns `false` then the\r\n * current drag sequence is stopped.\r\n * @property {function(boolean):boolean} [stopDown]\r\n * Should the down event be propagated to other interactions, or should be\r\n * stopped?\r\n */\n\n/**\r\n * @classdesc\r\n * Base class that calls user-defined functions on `down`, `move` and `up`\r\n * events. This class also manages \"drag sequences\".\r\n *\r\n * When the `handleDownEvent` user function returns `true` a drag sequence is\r\n * started. During a drag sequence the `handleDragEvent` user function is\r\n * called on `move` events. The drag sequence ends when the `handleUpEvent`\r\n * user function is called and returns `false`.\r\n * @api\r\n */\nclass PointerInteraction extends Interaction {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(/** @type {import(\"./Interaction.js\").InteractionOptions} */options);\n    if (options.handleDownEvent) {\n      this.handleDownEvent = options.handleDownEvent;\n    }\n    if (options.handleDragEvent) {\n      this.handleDragEvent = options.handleDragEvent;\n    }\n    if (options.handleMoveEvent) {\n      this.handleMoveEvent = options.handleMoveEvent;\n    }\n    if (options.handleUpEvent) {\n      this.handleUpEvent = options.handleUpEvent;\n    }\n    if (options.stopDown) {\n      this.stopDown = options.stopDown;\n    }\n\n    /**\r\n     * @type {boolean}\r\n     * @protected\r\n     */\n    this.handlingDownUpSequence = false;\n\n    /**\r\n     * @type {Array<PointerEvent>}\r\n     * @protected\r\n     */\n    this.targetPointers = [];\n  }\n\n  /**\r\n   * Returns the current number of pointers involved in the interaction,\r\n   * e.g. `2` when two fingers are used.\r\n   * @return {number} The number of pointers.\r\n   * @api\r\n   */\n  getPointerCount() {\n    return this.targetPointers.length;\n  }\n\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @protected\r\n   */\n  handleDownEvent(mapBrowserEvent) {\n    return false;\n  }\n\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @protected\r\n   */\n  handleDragEvent(mapBrowserEvent) {}\n\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into\r\n   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are\r\n   * detected.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @api\r\n   * @override\r\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n    let stopEvent = false;\n    this.updateTrackedPointers_(mapBrowserEvent);\n    if (this.handlingDownUpSequence) {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {\n        this.handleDragEvent(mapBrowserEvent);\n        // prevent page scrolling during dragging\n        mapBrowserEvent.originalEvent.preventDefault();\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\n        const handledUp = this.handleUpEvent(mapBrowserEvent);\n        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;\n      }\n    } else {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\n        const handled = this.handleDownEvent(mapBrowserEvent);\n        this.handlingDownUpSequence = handled;\n        stopEvent = this.stopDown(handled);\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {\n        this.handleMoveEvent(mapBrowserEvent);\n      }\n    }\n    return !stopEvent;\n  }\n\n  /**\r\n   * Handle pointer move events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @protected\r\n   */\n  handleMoveEvent(mapBrowserEvent) {}\n\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @protected\r\n   */\n  handleUpEvent(mapBrowserEvent) {\n    return false;\n  }\n\n  /**\r\n   * This function is used to determine if \"down\" events should be propagated\r\n   * to other interactions or should be stopped.\r\n   * @param {boolean} handled Was the event handled by the interaction?\r\n   * @return {boolean} Should the `down` event be stopped?\r\n   */\n  stopDown(handled) {\n    return handled;\n  }\n\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @private\r\n   */\n  updateTrackedPointers_(mapBrowserEvent) {\n    if (mapBrowserEvent.activePointers) {\n      this.targetPointers = mapBrowserEvent.activePointers;\n    }\n  }\n}\n\n/**\r\n * @param {Array<PointerEvent>} pointerEvents List of events.\r\n * @return {{clientX: number, clientY: number}} Centroid pixel.\r\n */\nexport function centroid(pointerEvents) {\n  const length = pointerEvents.length;\n  let clientX = 0;\n  let clientY = 0;\n  for (let i = 0; i < length; i++) {\n    clientX += pointerEvents[i].clientX;\n    clientY += pointerEvents[i].clientY;\n  }\n  return {\n    clientX: clientX / length,\n    clientY: clientY / length\n  };\n}\nexport default PointerInteraction;", "/**\r\n * @module ol/events/condition\r\n */\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { MAC, WEBKIT } from '../has.js';\nimport { assert } from '../asserts.js';\n\n/**\r\n * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * `{boolean}`. If the condition is met, true should be returned.\r\n *\r\n * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default): boolean} Condition\r\n */\n\n/**\r\n * Creates a condition function that passes when all provided conditions pass.\r\n * @param {...Condition} var_args Conditions to check.\r\n * @return {Condition} Condition function.\r\n */\nexport function all(var_args) {\n  const conditions = arguments;\n  /**\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @return {boolean} All conditions passed.\r\n   */\n  return function (event) {\n    let pass = true;\n    for (let i = 0, ii = conditions.length; i < ii; ++i) {\n      pass = pass && conditions[i](event);\n      if (!pass) {\n        break;\n      }\n    }\n    return pass;\n  };\n}\n\n/**\r\n * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when\r\n * additionally the shift-key is pressed).\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if only the alt key is pressed.\r\n * @api\r\n */\nexport const altKeyOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;\n};\n\n/**\r\n * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise\r\n * (e.g. when additionally the platform-modifier-key is pressed).\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if only the alt and shift keys are pressed.\r\n * @api\r\n */\nexport const altShiftKeysOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;\n};\n\n/**\r\n * Return `true` if the map has the focus. This condition requires a map target\r\n * element with a `tabindex` attribute, e.g. `<div id=\"map\" tabindex=\"1\">`.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\r\n * @return {boolean} The map has the focus.\r\n * @api\r\n */\nexport const focus = function (event) {\n  const targetElement = event.map.getTargetElement();\n  const rootNode = targetElement.getRootNode();\n  const activeElement = event.map.getOwnerDocument().activeElement;\n  return rootNode instanceof ShadowRoot ? rootNode.host.contains(activeElement) : targetElement.contains(activeElement);\n};\n\n/**\r\n * Return `true` if the map has the focus or no 'tabindex' attribute set.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\r\n * @return {boolean} The map container has the focus or no 'tabindex' attribute.\r\n */\nexport const focusWithTabindex = function (event) {\n  const targetElement = event.map.getTargetElement();\n  const rootNode = targetElement.getRootNode();\n  const tabIndexCandidate = rootNode instanceof ShadowRoot ? rootNode.host : targetElement;\n  return tabIndexCandidate.hasAttribute('tabindex') ? focus(event) : true;\n};\n\n/**\r\n * Return always true.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True.\r\n * @api\r\n */\nexport const always = TRUE;\n\n/**\r\n * Return `true` if the event is a `click` event, `false` otherwise.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event is a map `click` event.\r\n * @api\r\n */\nexport const click = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.CLICK;\n};\n\n/**\r\n * Return `true` if the event has an \"action\"-producing mouse button.\r\n *\r\n * By definition, this includes left-click on windows/linux, and left-click\r\n * without the ctrl key on Macs.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} The result.\r\n */\nexport const mouseActionButton = function (mapBrowserEvent) {\n  const originalEvent = /** @type {MouseEvent} */\n  mapBrowserEvent.originalEvent;\n  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);\n};\n\n/**\r\n * Return always false.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} False.\r\n * @api\r\n */\nexport const never = FALSE;\n\n/**\r\n * Return `true` if the browser event is a `pointermove` event, `false`\r\n * otherwise.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the browser event is a `pointermove` event.\r\n * @api\r\n */\nexport const pointerMove = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == 'pointermove';\n};\n\n/**\r\n * Return `true` if the event is a map `singleclick` event, `false` otherwise.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event is a map `singleclick` event.\r\n * @api\r\n */\nexport const singleClick = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;\n};\n\n/**\r\n * Return `true` if the event is a map `dblclick` event, `false` otherwise.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event is a map `dblclick` event.\r\n * @api\r\n */\nexport const doubleClick = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;\n};\n\n/**\r\n * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is\r\n * pressed.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True only if there no modifier keys are pressed.\r\n * @api\r\n */\nexport const noModifierKeys = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;\n};\n\n/**\r\n * Return `true` if only the platform-modifier-key (the meta-key on Mac,\r\n * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally\r\n * the shift-key is pressed).\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if only the platform modifier key is pressed.\r\n * @api\r\n */\nexport const platformModifierKeyOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return !originalEvent.altKey && (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;\n};\n\n/**\r\n * Return `true` if the platform-modifier-key (the meta-key on Mac,\r\n * ctrl-key otherwise) is pressed.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the platform modifier key is pressed.\r\n * @api\r\n */\nexport const platformModifierKey = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return MAC ? originalEvent.metaKey : originalEvent.ctrlKey;\n};\n\n/**\r\n * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when\r\n * additionally the alt-key is pressed).\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if only the shift key is pressed.\r\n * @api\r\n */\nexport const shiftKeyOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;\n};\n\n/**\r\n * Return `true` if the target element is not editable, i.e. not an `input`,\r\n * `select`, or `textarea` element and no `contenteditable` attribute is\r\n * set or inherited, `false` otherwise.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True only if the target element is not editable.\r\n * @api\r\n */\nexport const targetNotEditable = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  const tagName = /** @type {Element} */originalEvent.target.tagName;\n  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA' &&\n  // `isContentEditable` is only available on `HTMLElement`, but it may also be a\n  // different type like `SVGElement`.\n  // @ts-ignore\n  !originalEvent.target.isContentEditable;\n};\n\n/**\r\n * Return `true` if the event originates from a mouse device.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event originates from a mouse device.\r\n * @api\r\n */\nexport const mouseOnly = function (mapBrowserEvent) {\n  const pointerEvent = /** @type {import(\"../MapBrowserEvent\").default} */mapBrowserEvent.originalEvent;\n  assert(pointerEvent !== undefined, 'mapBrowserEvent must originate from a pointer event');\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n  return pointerEvent.pointerType == 'mouse';\n};\n\n/**\r\n * Return `true` if the event originates from a touchable device.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event originates from a touchable device.\r\n * @api\r\n */\nexport const touchOnly = function (mapBrowserEvent) {\n  const pointerEvt = /** @type {import(\"../MapBrowserEvent\").default} */mapBrowserEvent.originalEvent;\n  assert(pointerEvt !== undefined, 'mapBrowserEvent must originate from a pointer event');\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n  return pointerEvt.pointerType === 'touch';\n};\n\n/**\r\n * Return `true` if the event originates from a digital pen.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event originates from a digital pen.\r\n * @api\r\n */\nexport const penOnly = function (mapBrowserEvent) {\n  const pointerEvt = /** @type {import(\"../MapBrowserEvent\").default} */mapBrowserEvent.originalEvent;\n  assert(pointerEvt !== undefined, 'mapBrowserEvent must originate from a pointer event');\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n  return pointerEvt.pointerType === 'pen';\n};\n\n/**\r\n * Return `true` if the event originates from a primary pointer in\r\n * contact with the surface or if the left mouse button is pressed.\r\n * See https://www.w3.org/TR/pointerevents/#button-states.\r\n *\r\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n * @return {boolean} True if the event originates from a primary pointer.\r\n * @api\r\n */\nexport const primaryAction = function (mapBrowserEvent) {\n  const pointerEvent = /** @type {import(\"../MapBrowserEvent\").default} */mapBrowserEvent.originalEvent;\n  assert(pointerEvent !== undefined, 'mapBrowserEvent must originate from a pointer event');\n  return pointerEvent.isPrimary && pointerEvent.button === 0;\n};", "/**\r\n * @module ol/interaction/DragPan\r\n */\nimport PointerInteraction, { centroid as centroidFromPointers } from './Pointer.js';\nimport { FALSE } from '../functions.js';\nimport { all, focusWithTabindex, noModifierKeys, primaryAction } from '../events/condition.js';\nimport { easeOut } from '../easing.js';\nimport { rotate as rotateCoordinate, scale as scaleCoordinate } from '../coordinate.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\r\n * to indicate whether that event should be handled.\r\n * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.\r\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\r\n * the interaction will only handle events when the map has the focus.\r\n * @property {import(\"../Kinetic.js\").default} [kinetic] Kinetic inertia to apply to the pan.\r\n */\n\n/**\r\n * @classdesc\r\n * Allows the user to pan the map by dragging the map.\r\n * @api\r\n */\nclass DragPan extends PointerInteraction {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    super({\n      stopDown: FALSE\n    });\n    options = options ? options : {};\n\n    /**\r\n     * @private\r\n     * @type {import(\"../Kinetic.js\").default|undefined}\r\n     */\n    this.kinetic_ = options.kinetic;\n\n    /**\r\n     * @type {import(\"../pixel.js\").Pixel}\r\n     */\n    this.lastCentroid = null;\n\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.lastPointersCount_;\n\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\n    this.panning_ = false;\n    const condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);\n\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\n    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.noKinetic_ = false;\n  }\n\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @override\r\n   */\n  handleDragEvent(mapBrowserEvent) {\n    const map = mapBrowserEvent.map;\n    if (!this.panning_) {\n      this.panning_ = true;\n      map.getView().beginInteraction();\n    }\n    const targetPointers = this.targetPointers;\n    const centroid = map.getEventPixel(centroidFromPointers(targetPointers));\n    if (targetPointers.length == this.lastPointersCount_) {\n      if (this.kinetic_) {\n        this.kinetic_.update(centroid[0], centroid[1]);\n      }\n      if (this.lastCentroid) {\n        const delta = [this.lastCentroid[0] - centroid[0], centroid[1] - this.lastCentroid[1]];\n        const map = mapBrowserEvent.map;\n        const view = map.getView();\n        scaleCoordinate(delta, view.getResolution());\n        rotateCoordinate(delta, view.getRotation());\n        view.adjustCenterInternal(delta);\n      }\n    } else if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger down, tiny drag, second finger down\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = centroid;\n    this.lastPointersCount_ = targetPointers.length;\n    mapBrowserEvent.originalEvent.preventDefault();\n  }\n\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\n  handleUpEvent(mapBrowserEvent) {\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (this.targetPointers.length === 0) {\n      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n        const distance = this.kinetic_.getDistance();\n        const angle = this.kinetic_.getAngle();\n        const center = view.getCenterInternal();\n        const centerpx = map.getPixelFromCoordinateInternal(center);\n        const dest = map.getCoordinateFromPixelInternal([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);\n        view.animateInternal({\n          center: view.getConstrainedCenter(dest),\n          duration: 500,\n          easing: easeOut\n        });\n      }\n      if (this.panning_) {\n        this.panning_ = false;\n        view.endInteraction();\n      }\n      return false;\n    }\n    if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger up, tiny drag, second finger up\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = null;\n    return true;\n  }\n\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      this.lastCentroid = null;\n      // stop any current animation\n      if (view.getAnimating()) {\n        view.cancelAnimations();\n      }\n      if (this.kinetic_) {\n        this.kinetic_.begin();\n      }\n      // No kinetic as soon as more than one pointer on the screen is\n      // detected. This is to prevent nasty pans after pinch.\n      this.noKinetic_ = this.targetPointers.length > 1;\n      return true;\n    }\n    return false;\n  }\n}\nexport default DragPan;", "/**\r\n * @module ol/interaction/DragRotate\r\n */\nimport PointerInteraction from './Pointer.js';\nimport { FALSE } from '../functions.js';\nimport { altShiftKeysOnly, mouseActionButton, mouseOnly } from '../events/condition.js';\nimport { disable } from '../rotationconstraint.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes a\r\n * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\r\n * to indicate whether that event should be handled.\r\n * Default is {@link module:ol/events/condition.altShiftKeysOnly}.\r\n * @property {number} [duration=250] Animation duration in milliseconds.\r\n */\n\n/**\r\n * @classdesc\r\n * Allows the user to rotate the map by clicking and dragging on the map,\r\n * normally combined with a {@link module:ol/events/condition} that limits\r\n * it to when the alt and shift keys are held down.\r\n *\r\n * This interaction is only supported for mouse devices.\r\n * @api\r\n */\nclass DragRotate extends PointerInteraction {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super({\n      stopDown: FALSE\n    });\n\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\n    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;\n\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\n    this.lastAngle_ = undefined;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @override\r\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return;\n    }\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n    const size = map.getSize();\n    const offset = mapBrowserEvent.pixel;\n    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);\n    if (this.lastAngle_ !== undefined) {\n      const delta = theta - this.lastAngle_;\n      view.adjustRotationInternal(-delta);\n    }\n    this.lastAngle_ = theta;\n  }\n\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return true;\n    }\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    view.endInteraction(this.duration_);\n    return false;\n  }\n\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return false;\n    }\n    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {\n      const map = mapBrowserEvent.map;\n      map.getView().beginInteraction();\n      this.lastAngle_ = undefined;\n      return true;\n    }\n    return false;\n  }\n}\nexport default DragRotate;", "/**\r\n * @module ol/render/Box\r\n */\n\nimport Disposable from '../Disposable.js';\nimport Polygon from '../geom/Polygon.js';\nclass RenderBox extends Disposable {\n  /**\r\n   * @param {string} className CSS class name.\r\n   */\n  constructor(className) {\n    super();\n\n    /**\r\n     * @type {import(\"../geom/Polygon.js\").default}\r\n     * @private\r\n     */\n    this.geometry_ = null;\n\n    /**\r\n     * @type {HTMLDivElement}\r\n     * @private\r\n     */\n    this.element_ = document.createElement('div');\n    this.element_.style.position = 'absolute';\n    this.element_.style.pointerEvents = 'auto';\n    this.element_.className = 'ol-box ' + className;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../Map.js\").default|null}\r\n     */\n    this.map_ = null;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../pixel.js\").Pixel}\r\n     */\n    this.startPixel_ = null;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../pixel.js\").Pixel}\r\n     */\n    this.endPixel_ = null;\n  }\n\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\n  disposeInternal() {\n    this.setMap(null);\n  }\n\n  /**\r\n   * @private\r\n   */\n  render_() {\n    const startPixel = this.startPixel_;\n    const endPixel = this.endPixel_;\n    const px = 'px';\n    const style = this.element_.style;\n    style.left = Math.min(startPixel[0], endPixel[0]) + px;\n    style.top = Math.min(startPixel[1], endPixel[1]) + px;\n    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;\n    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;\n  }\n\n  /**\r\n   * @param {import(\"../Map.js\").default|null} map Map.\r\n   */\n  setMap(map) {\n    if (this.map_) {\n      this.map_.getOverlayContainer().removeChild(this.element_);\n      const style = this.element_.style;\n      style.left = 'inherit';\n      style.top = 'inherit';\n      style.width = 'inherit';\n      style.height = 'inherit';\n    }\n    this.map_ = map;\n    if (this.map_) {\n      this.map_.getOverlayContainer().appendChild(this.element_);\n    }\n  }\n\n  /**\r\n   * @param {import(\"../pixel.js\").Pixel} startPixel Start pixel.\r\n   * @param {import(\"../pixel.js\").Pixel} endPixel End pixel.\r\n   */\n  setPixels(startPixel, endPixel) {\n    this.startPixel_ = startPixel;\n    this.endPixel_ = endPixel;\n    this.createOrUpdateGeometry();\n    this.render_();\n  }\n\n  /**\r\n   * Creates or updates the cached geometry.\r\n   */\n  createOrUpdateGeometry() {\n    if (!this.map_) {\n      return;\n    }\n    const startPixel = this.startPixel_;\n    const endPixel = this.endPixel_;\n    const pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];\n    const coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);\n    // close the polygon\n    coordinates[4] = coordinates[0].slice();\n    if (!this.geometry_) {\n      this.geometry_ = new Polygon([coordinates]);\n    } else {\n      this.geometry_.setCoordinates([coordinates]);\n    }\n  }\n\n  /**\r\n   * @return {import(\"../geom/Polygon.js\").default} Geometry.\r\n   */\n  getGeometry() {\n    return this.geometry_;\n  }\n}\nexport default RenderBox;", "/**\r\n * @module ol/interaction/DragBox\r\n */\n// FIXME draw drag box\nimport Event from '../events/Event.js';\nimport PointerInteraction from './Pointer.js';\nimport RenderBox from '../render/Box.js';\nimport { mouseActionButton } from '../events/condition.js';\n\n/**\r\n * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\r\n * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,\r\n * true should be returned.\r\n * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default, import(\"../pixel.js\").Pixel, import(\"../pixel.js\").Pixel):boolean} EndCondition\r\n */\n\n/**\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-dragbox'] CSS class name for styling the box.\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\r\n * to indicate whether that event should be handled.\r\n * Default is {@link ol/events/condition~mouseActionButton}.\r\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default\r\n * `boxEndCondition` function.\r\n * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\r\n * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.\r\n * Default is `true` if the area of the box is bigger than the `minArea` option.\r\n * @property {function(this:DragBox, import(\"../MapBrowserEvent.js\").default):void} [onBoxEnd] Code to execute just\r\n * before `boxend` is fired.\r\n */\n\n/**\r\n * @enum {string}\r\n */\nconst DragBoxEventType = {\n  /**\r\n   * Triggered upon drag box start.\r\n   * @event DragBoxEvent#boxstart\r\n   * @api\r\n   */\n  BOXSTART: 'boxstart',\n  /**\r\n   * Triggered on drag when box is active.\r\n   * @event DragBoxEvent#boxdrag\r\n   * @api\r\n   */\n  BOXDRAG: 'boxdrag',\n  /**\r\n   * Triggered upon drag box end.\r\n   * @event DragBoxEvent#boxend\r\n   * @api\r\n   */\n  BOXEND: 'boxend',\n  /**\r\n   * Triggered upon drag box canceled.\r\n   * @event DragBoxEvent#boxcancel\r\n   * @api\r\n   */\n  BOXCANCEL: 'boxcancel'\n};\n\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of\r\n * this type.\r\n */\nexport class DragBoxEvent extends Event {\n  /**\r\n   * @param {string} type The event type.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Originating event.\r\n   */\n  constructor(type, coordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\r\n     * The coordinate of the drag event.\r\n     * @const\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     * @api\r\n     */\n    this.coordinate = coordinate;\n\n    /**\r\n     * @const\r\n     * @type {import(\"../MapBrowserEvent.js\").default}\r\n     * @api\r\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\r\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature\r\n */\n\n/**\r\n * @classdesc\r\n * Allows the user to draw a vector box by clicking and dragging on the map,\r\n * normally combined with a {@link module:ol/events/condition} that limits\r\n * it to when the shift or other key is held down. This is used, for example,\r\n * for zooming to a specific area of the map\r\n * (see {@link module:ol/interaction/DragZoom~DragZoom} and\r\n * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).\r\n *\r\n * @fires DragBoxEvent\r\n * @api\r\n */\nclass DragBox extends PointerInteraction {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    super();\n\n    /***\r\n     * @type {DragBoxOnSignature<import(\"../events\").EventsKey>}\r\n     */\n    this.on;\n\n    /***\r\n     * @type {DragBoxOnSignature<import(\"../events\").EventsKey>}\r\n     */\n    this.once;\n\n    /***\r\n     * @type {DragBoxOnSignature<void>}\r\n     */\n    this.un;\n    options = options ?? {};\n\n    /**\r\n     * @type {import(\"../render/Box.js\").default}\r\n     * @private\r\n     */\n    this.box_ = new RenderBox(options.className || 'ol-dragbox');\n\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.minArea_ = options.minArea ?? 64;\n    if (options.onBoxEnd) {\n      this.onBoxEnd = options.onBoxEnd;\n    }\n\n    /**\r\n     * @type {import(\"../pixel.js\").Pixel}\r\n     * @private\r\n     */\n    this.startPixel_ = null;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\n    this.condition_ = options.condition ?? mouseActionButton;\n\n    /**\r\n     * @private\r\n     * @type {EndCondition}\r\n     */\n    this.boxEndCondition_ = options.boxEndCondition ?? this.defaultBoxEndCondition;\n  }\n\n  /**\r\n   * The default condition for determining whether the boxend event\r\n   * should fire.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent The originating MapBrowserEvent\r\n   *     leading to the box end.\r\n   * @param {import(\"../pixel.js\").Pixel} startPixel The starting pixel of the box.\r\n   * @param {import(\"../pixel.js\").Pixel} endPixel The end pixel of the box.\r\n   * @return {boolean} Whether or not the boxend condition should be fired.\r\n   */\n  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {\n    const width = endPixel[0] - startPixel[0];\n    const height = endPixel[1] - startPixel[1];\n    return width * width + height * height >= this.minArea_;\n  }\n\n  /**\r\n   * Returns geometry of last drawn box.\r\n   * @return {import(\"../geom/Polygon.js\").default} Geometry.\r\n   * @api\r\n   */\n  getGeometry() {\n    return this.box_.getGeometry();\n  }\n\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @override\r\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (!this.startPixel_) {\n      return;\n    }\n    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));\n  }\n\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (!this.startPixel_) {\n      return false;\n    }\n    const completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);\n    if (completeBox) {\n      this.onBoxEnd(mapBrowserEvent);\n    }\n    this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));\n    this.box_.setMap(null);\n    this.startPixel_ = null;\n    return false;\n  }\n\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.condition_(mapBrowserEvent)) {\n      this.startPixel_ = mapBrowserEvent.pixel;\n      this.box_.setMap(mapBrowserEvent.map);\n      this.box_.setPixels(this.startPixel_, this.startPixel_);\n      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));\n      return true;\n    }\n    return false;\n  }\n\n  /**\r\n   * Function to execute just before `onboxend` is fired\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   */\n  onBoxEnd(event) {}\n\n  /**\r\n   * Activate or deactivate the interaction.\r\n   * @param {boolean} active Active.\r\n   * @observable\r\n   * @api\r\n   * @override\r\n   */\n  setActive(active) {\n    if (!active) {\n      this.box_.setMap(null);\n      if (this.startPixel_) {\n        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null));\n        this.startPixel_ = null;\n      }\n    }\n    super.setActive(active);\n  }\n\n  /**\r\n   * @param {import(\"../Map.js\").default|null} map Map.\r\n   * @override\r\n   */\n  setMap(map) {\n    const oldMap = this.getMap();\n    if (oldMap) {\n      this.box_.setMap(null);\n      if (this.startPixel_) {\n        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null));\n        this.startPixel_ = null;\n      }\n    }\n    super.setMap(map);\n  }\n}\nexport default DragBox;", "/**\r\n * @module ol/interaction/DragZoom\r\n */\nimport DragBox from './DragBox.js';\nimport { easeOut } from '../easing.js';\nimport { shiftKeyOnly } from '../events/condition.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-dragzoom'] CSS class name for styling the\r\n * box.\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled.\r\n * Default is {@link module:ol/events/condition.shiftKeyOnly}.\r\n * @property {number} [duration=200] Animation duration in milliseconds.\r\n * @property {boolean} [out=false] Use interaction for zooming out.\r\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default\r\n * `boxEndCondition` function.\r\n */\n\n/**\r\n * @classdesc\r\n * Allows the user to zoom the map by clicking and dragging on the map,\r\n * normally combined with a {@link module:ol/events/condition} that limits\r\n * it to when a key, shift by default, is held down.\r\n *\r\n * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or\r\n * your custom one configured with `className`.\r\n * @api\r\n */\nclass DragZoom extends DragBox {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const condition = options.condition ? options.condition : shiftKeyOnly;\n    super({\n      condition: condition,\n      className: options.className || 'ol-dragzoom',\n      minArea: options.minArea\n    });\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.out_ = options.out !== undefined ? options.out : false;\n  }\n\n  /**\r\n   * Function to execute just before `onboxend` is fired\r\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\r\n   * @override\r\n   */\n  onBoxEnd(event) {\n    const map = this.getMap();\n    const view = /** @type {!import(\"../View.js\").default} */map.getView();\n    let geometry = this.getGeometry();\n    if (this.out_) {\n      const rotatedExtent = view.rotatedExtentForGeometry(geometry);\n      const resolution = view.getResolutionForExtentInternal(rotatedExtent);\n      const factor = view.getResolution() / resolution;\n      geometry = geometry.clone();\n      geometry.scale(factor * factor);\n    }\n    view.fitInternal(geometry, {\n      duration: this.duration_,\n      easing: easeOut\n    });\n  }\n}\nexport default DragZoom;", "/**\r\n * @module ol/events/Key\r\n */\n\n/**\r\n * @enum {string}\r\n * @const\r\n */\nexport default {\n  LEFT: 'ArrowLeft',\n  UP: 'ArrowUp',\n  RIGHT: 'ArrowRight',\n  DOWN: 'ArrowDown'\n};", "/**\r\n * @module ol/interaction/KeyboardPan\r\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, { pan } from './Interaction.js';\nimport Key from '../events/Key.js';\nimport { noModifierKeys, targetNotEditable } from '../events/condition.js';\nimport { rotate as rotateCoordinate } from '../coordinate.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled. Default is\r\n * {@link module:ol/events/condition.noModifierKeys} and\r\n * {@link module:ol/events/condition.targetNotEditable}.\r\n * @property {number} [duration=100] Animation duration in milliseconds.\r\n * @property {number} [pixelDelta=128] The amount of pixels to pan on each key\r\n * press.\r\n */\n\n/**\r\n * @classdesc\r\n * Allows the user to pan the map using keyboard arrows.\r\n * Note that, although this interaction is by default included in maps,\r\n * the keys can only be used when browser focus is on the element to which\r\n * the keyboard events are attached. By default, this is the map div,\r\n * though you can change this with the `keyboardEventTarget` in\r\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\r\n * element, focus will have to be on, and returned to, this element if the keys\r\n * are to function.\r\n * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.\r\n * @api\r\n */\nclass KeyboardPan extends Interaction {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    super();\n    options = options || {};\n\n    /**\r\n     * @private\r\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\r\n     * @return {boolean} Combined condition result.\r\n     */\n    this.defaultCondition_ = function (mapBrowserEvent) {\n      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);\n    };\n\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\n    this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;\n  }\n\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a\r\n   * `KeyEvent`, and decides the direction to pan to (if an arrow key was\r\n   * pressed).\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @override\r\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == EventType.KEYDOWN) {\n      const keyEvent = /** @type {KeyboardEvent} */\n      mapBrowserEvent.originalEvent;\n      const key = keyEvent.key;\n      if (this.condition_(mapBrowserEvent) && (key == Key.DOWN || key == Key.LEFT || key == Key.RIGHT || key == Key.UP)) {\n        const map = mapBrowserEvent.map;\n        const view = map.getView();\n        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;\n        let deltaX = 0,\n          deltaY = 0;\n        if (key == Key.DOWN) {\n          deltaY = -mapUnitsDelta;\n        } else if (key == Key.LEFT) {\n          deltaX = -mapUnitsDelta;\n        } else if (key == Key.RIGHT) {\n          deltaX = mapUnitsDelta;\n        } else {\n          deltaY = mapUnitsDelta;\n        }\n        const delta = [deltaX, deltaY];\n        rotateCoordinate(delta, view.getRotation());\n        pan(view, delta, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  }\n}\nexport default KeyboardPan;", "/**\r\n * @module ol/interaction/KeyboardZoom\r\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, { zoomByDelta } from './Interaction.js';\nimport { platformModifierKey, targetNotEditable } from '../events/condition.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [duration=100] Animation duration in milliseconds.\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled. The default condition is\r\n * that {@link module:ol/events/condition.targetNotEditable} is fulfilled and that\r\n * the platform modifier key isn't pressed\r\n * (!{@link module:ol/events/condition.platformModifierKey}).\r\n * @property {number} [delta=1] The zoom level delta on each key press.\r\n */\n\n/**\r\n * @classdesc\r\n * Allows the user to zoom the map using keyboard + and -.\r\n * Note that, although this interaction is by default included in maps,\r\n * the keys can only be used when browser focus is on the element to which\r\n * the keyboard events are attached. By default, this is the map div,\r\n * though you can change this with the `keyboardEventTarget` in\r\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\r\n * element, focus will have to be on, and returned to, this element if the keys\r\n * are to function.\r\n * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.\r\n * @api\r\n */\nclass KeyboardZoom extends Interaction {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\n    this.condition_ = options.condition ? options.condition : function (mapBrowserEvent) {\n      return !platformModifierKey(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);\n    };\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n  }\n\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a\r\n   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the\r\n   * key pressed was '+' or '-').\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @override\r\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == EventType.KEYDOWN || mapBrowserEvent.type == EventType.KEYPRESS) {\n      const keyEvent = /** @type {KeyboardEvent} */\n      mapBrowserEvent.originalEvent;\n      const key = keyEvent.key;\n      if (this.condition_(mapBrowserEvent) && (key === '+' || key === '-')) {\n        const map = mapBrowserEvent.map;\n        const delta = key === '+' ? this.delta_ : -this.delta_;\n        const view = map.getView();\n        zoomByDelta(view, delta, undefined, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  }\n}\nexport default KeyboardZoom;", "/**\r\n * @module ol/Kinetic\r\n */\n\n/**\r\n * @classdesc\r\n * Implementation of inertial deceleration for map movement.\r\n *\r\n * @api\r\n */\nclass Kinetic {\n  /**\r\n   * @param {number} decay Rate of decay (must be negative).\r\n   * @param {number} minVelocity Minimum velocity (pixels/millisecond).\r\n   * @param {number} delay Delay to consider to calculate the kinetic\r\n   *     initial values (milliseconds).\r\n   */\n  constructor(decay, minVelocity, delay) {\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.decay_ = decay;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.minVelocity_ = minVelocity;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.delay_ = delay;\n\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\n    this.points_ = [];\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.angle_ = 0;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.initialVelocity_ = 0;\n  }\n\n  /**\r\n   * FIXME empty description for jsdoc\r\n   */\n  begin() {\n    this.points_.length = 0;\n    this.angle_ = 0;\n    this.initialVelocity_ = 0;\n  }\n\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   */\n  update(x, y) {\n    this.points_.push(x, y, Date.now());\n  }\n\n  /**\r\n   * @return {boolean} Whether we should do kinetic animation.\r\n   */\n  end() {\n    if (this.points_.length < 6) {\n      // at least 2 points are required (i.e. there must be at least 6 elements\n      // in the array)\n      return false;\n    }\n    const delay = Date.now() - this.delay_;\n    const lastIndex = this.points_.length - 3;\n    if (this.points_[lastIndex + 2] < delay) {\n      // the last tracked point is too old, which means that the user stopped\n      // panning before releasing the map\n      return false;\n    }\n\n    // get the first point which still falls into the delay time\n    let firstIndex = lastIndex - 3;\n    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {\n      firstIndex -= 3;\n    }\n    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];\n    // we don't want a duration of 0 (divide by zero)\n    // we also make sure the user panned for a duration of at least one frame\n    // (1/60s) to compute sane displacement values\n    if (duration < 1000 / 60) {\n      return false;\n    }\n    const dx = this.points_[lastIndex] - this.points_[firstIndex];\n    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];\n    this.angle_ = Math.atan2(dy, dx);\n    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;\n    return this.initialVelocity_ > this.minVelocity_;\n  }\n\n  /**\r\n   * @return {number} Total distance travelled (pixels).\r\n   */\n  getDistance() {\n    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;\n  }\n\n  /**\r\n   * @return {number} Angle of the kinetic panning animation (radians).\r\n   */\n  getAngle() {\n    return this.angle_;\n  }\n}\nexport default Kinetic;", "/**\r\n * @module ol/interaction/MouseWheelZoom\r\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, { zoomByDelta } from './Interaction.js';\nimport { DEVICE_PIXEL_RATIO, FIREFOX } from '../has.js';\nimport { all, always, focusWithTabindex } from '../events/condition.js';\nimport { clamp } from '../math.js';\n\n/**\r\n * @typedef {'trackpad' | 'wheel'} Mode\r\n */\n\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\r\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\r\n * boolean to indicate whether that event should be handled. Default is\r\n * {@link module:ol/events/condition.always}.\r\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\r\n * the interaction will only handle events when the map has the focus.\r\n * @property {number} [maxDelta=1] Maximum mouse wheel delta.\r\n * @property {number} [duration=250] Animation duration in milliseconds.\r\n * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.\r\n * @property {boolean} [useAnchor=true] Enable zooming using the mouse's\r\n * location as the anchor. When set to `false`, zooming in and out will zoom to\r\n * the center of the screen instead of zooming on the mouse's location.\r\n * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom\r\n * event will always animate to the closest zoom level after an interaction;\r\n * false means intermediary zoom levels are allowed.\r\n */\n\n/**\r\n * @classdesc\r\n * Allows the user to zoom the map by scrolling the mouse wheel.\r\n * @api\r\n */\nclass MouseWheelZoom extends Interaction {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(/** @type {import(\"./Interaction.js\").InteractionOptions} */options);\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.totalDelta_ = 0;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.lastDelta_ = 0;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.constrainResolution_ = options.constrainResolution !== undefined ? options.constrainResolution : false;\n    const condition = options.condition ? options.condition : always;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../events/condition.js\").Condition}\r\n     */\n    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;\n\n    /**\r\n     * @private\r\n     * @type {?import(\"../pixel.js\").Pixel}\r\n     */\n    this.lastAnchor_ = null;\n\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\n    this.startTime_ = undefined;\n\n    /**\r\n     * @private\r\n     * @type {ReturnType<typeof setTimeout>}\r\n     */\n    this.timeoutId_;\n\n    /**\r\n     * @private\r\n     * @type {Mode|undefined}\r\n     */\n    this.mode_ = undefined;\n\n    /**\r\n     * Trackpad events separated by this delay will be considered separate\r\n     * interactions.\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.trackpadEventGap_ = 400;\n\n    /**\r\n     * @private\r\n     * @type {ReturnType<typeof setTimeout>}\r\n     */\n    this.trackpadTimeoutId_;\n\n    /**\r\n     * The number of delta values per zoom level\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.deltaPerZoom_ = 300;\n  }\n\n  /**\r\n   * @private\r\n   */\n  endInteraction_() {\n    this.trackpadTimeoutId_ = undefined;\n    const map = this.getMap();\n    if (!map) {\n      return;\n    }\n    const view = map.getView();\n    view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null);\n  }\n\n  /**\r\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually\r\n   * zooms the map.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\r\n   * @return {boolean} `false` to stop event propagation.\r\n   * @override\r\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const type = mapBrowserEvent.type;\n    if (type !== EventType.WHEEL) {\n      return true;\n    }\n    const map = mapBrowserEvent.map;\n    const wheelEvent = /** @type {WheelEvent} */\n    mapBrowserEvent.originalEvent;\n    wheelEvent.preventDefault();\n    if (this.useAnchor_) {\n      this.lastAnchor_ = mapBrowserEvent.pixel;\n    }\n\n    // Delta normalisation inspired by\n    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js\n    let delta;\n    if (mapBrowserEvent.type == EventType.WHEEL) {\n      delta = wheelEvent.deltaY;\n      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {\n        delta /= DEVICE_PIXEL_RATIO;\n      }\n      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n        delta *= 40;\n      }\n    }\n    if (delta === 0) {\n      return false;\n    }\n    this.lastDelta_ = delta;\n    const now = Date.now();\n    if (this.startTime_ === undefined) {\n      this.startTime_ = now;\n    }\n    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {\n      this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';\n    }\n    const view = map.getView();\n    if (this.mode_ === 'trackpad' && !(view.getConstrainResolution() || this.constrainResolution_)) {\n      if (this.trackpadTimeoutId_) {\n        clearTimeout(this.trackpadTimeoutId_);\n      } else {\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        view.beginInteraction();\n      }\n      this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);\n      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null);\n      this.startTime_ = now;\n      return false;\n    }\n    this.totalDelta_ += delta;\n    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);\n    clearTimeout(this.timeoutId_);\n    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);\n    return false;\n  }\n\n  /**\r\n   * @private\r\n   * @param {import(\"../Map.js\").default} map Map.\r\n   */\n  handleWheelZoom_(map) {\n    const view = map.getView();\n    if (view.getAnimating()) {\n      view.cancelAnimations();\n    }\n    let delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;\n    if (view.getConstrainResolution() || this.constrainResolution_) {\n      // view has a zoom constraint, zoom by 1\n      delta = delta ? delta > 0 ? 1 : -1 : 0;\n    }\n    zoomByDelta(view, delta, this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null, this.duration_);\n    this.mode_ = undefined;\n    this.totalDelta_ = 0;\n    this.lastAnchor_ = null;\n    this.startTime_ = undefined;\n    this.timeoutId_ = undefined;\n  }\n\n  /**\r\n   * Enable or disable using the mouse's location as an anchor when zooming\r\n   * @param {boolean} useAnchor true to zoom to the mouse's location, false\r\n   * to zoom to the center of the map\r\n   * @api\r\n   */\n  setMouseAnchor(useAnchor) {\n    this.useAnchor_ = useAnchor;\n    if (!useAnchor) {\n      this.lastAnchor_ = null;\n    }\n  }\n}\nexport default MouseWheelZoom;", "/**\r\n * @module ol/interaction/PinchRotate\r\n */\nimport PointerInteraction, { centroid as centroidFromPointers } from './Pointer.js';\nimport { FALSE } from '../functions.js';\nimport { disable } from '../rotationconstraint.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [duration=250] The duration of the animation in\r\n * milliseconds.\r\n * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\r\n */\n\n/**\r\n * @classdesc\r\n * Allows the user to rotate the map by twisting with two fingers\r\n * on a touch screen.\r\n * @api\r\n */\nclass PinchRotate extends PointerInteraction {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */\n    options;\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    super(pointerOptions);\n\n    /**\r\n     * @private\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     */\n    this.anchor_ = null;\n\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\n    this.lastAngle_ = undefined;\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.rotating_ = false;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.rotationDelta_ = 0.0;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @override\r\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let rotationDelta = 0.0;\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n\n    // angle between touches\n    const angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);\n    if (this.lastAngle_ !== undefined) {\n      const delta = angle - this.lastAngle_;\n      this.rotationDelta_ += delta;\n      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {\n        this.rotating_ = true;\n      }\n      rotationDelta = delta;\n    }\n    this.lastAngle_ = angle;\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n\n    // rotate anchor point.\n    // FIXME: should be the intersection point between the lines:\n    //     touch0,touch1 and previousTouch0,previousTouch1\n    this.anchor_ = map.getCoordinateFromPixelInternal(map.getEventPixel(centroidFromPointers(this.targetPointers)));\n\n    // rotate\n    if (this.rotating_) {\n      map.render();\n      view.adjustRotationInternal(rotationDelta, this.anchor_);\n    }\n  }\n\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      view.endInteraction(this.duration_);\n      return false;\n    }\n    return true;\n  }\n\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastAngle_ = undefined;\n      this.rotating_ = false;\n      this.rotationDelta_ = 0.0;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    }\n    return false;\n  }\n}\nexport default PinchRotate;", "/**\r\n * @module ol/interaction/PinchZoom\r\n */\nimport PointerInteraction, { centroid as centroidFromPointers } from './Pointer.js';\nimport { FALSE } from '../functions.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [duration=400] Animation duration in milliseconds.\r\n */\n\n/**\r\n * @classdesc\r\n * Allows the user to zoom the map by pinching with two fingers\r\n * on a touch screen.\r\n * @api\r\n */\nclass PinchZoom extends PointerInteraction {\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */\n    options;\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    super(pointerOptions);\n\n    /**\r\n     * @private\r\n     * @type {import(\"../coordinate.js\").Coordinate}\r\n     */\n    this.anchor_ = null;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 400;\n\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\n    this.lastDistance_ = undefined;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.lastScaleDelta_ = 1;\n  }\n\n  /**\r\n   * Handle pointer drag events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @override\r\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let scaleDelta = 1.0;\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n    const dx = touch0.clientX - touch1.clientX;\n    const dy = touch0.clientY - touch1.clientY;\n\n    // distance between touches\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (this.lastDistance_ !== undefined) {\n      scaleDelta = this.lastDistance_ / distance;\n    }\n    this.lastDistance_ = distance;\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (scaleDelta != 1.0) {\n      this.lastScaleDelta_ = scaleDelta;\n    }\n\n    // scale anchor point.\n    this.anchor_ = map.getCoordinateFromPixelInternal(map.getEventPixel(centroidFromPointers(this.targetPointers)));\n\n    // scale, bypass the resolution constraint\n    map.render();\n    view.adjustResolutionInternal(scaleDelta, this.anchor_);\n  }\n\n  /**\r\n   * Handle pointer up events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;\n      view.endInteraction(this.duration_, direction);\n      return false;\n    }\n    return true;\n  }\n\n  /**\r\n   * Handle pointer down events.\r\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\r\n   * @return {boolean} If the event was consumed.\r\n   * @override\r\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastDistance_ = undefined;\n      this.lastScaleDelta_ = 1;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    }\n    return false;\n  }\n}\nexport default PinchZoom;", "/**\r\n * @module ol/interaction/defaults\r\n */\nimport Collection from '../Collection.js';\nimport DoubleClickZoom from './DoubleClickZoom.js';\nimport DragPan from './DragPan.js';\nimport DragRotate from './DragRotate.js';\nimport DragZoom from './DragZoom.js';\nimport KeyboardPan from './KeyboardPan.js';\nimport KeyboardZoom from './KeyboardZoom.js';\nimport Kinetic from '../Kinetic.js';\nimport MouseWheelZoom from './MouseWheelZoom.js';\nimport PinchRotate from './PinchRotate.js';\nimport PinchZoom from './PinchZoom.js';\n\n/**\r\n * @typedef {Object} DefaultsOptions\r\n * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is\r\n * desired.\r\n * @property {boolean} [onFocusOnly=false] Interact only when the map has the\r\n * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is\r\n * useful when page scroll is desired for maps that do not have the browser's\r\n * focus.\r\n * @property {boolean} [doubleClickZoom=true] Whether double click zoom is\r\n * desired.\r\n * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.\r\n * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.\r\n * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.\r\n * @property {boolean} [dragPan=true] Whether drag pan is desired.\r\n * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.\r\n * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.\r\n * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.\r\n * @property {number} [zoomDuration] Duration of the zoom animation in\r\n * milliseconds.\r\n */\n\n/**\r\n * Set of interactions included in maps by default. Specific interactions can be\r\n * excluded by setting the appropriate option to false in the constructor\r\n * options, but the order of the interactions is fixed.  If you want to specify\r\n * a different order for interactions, you will need to create your own\r\n * {@link module:ol/interaction/Interaction~Interaction} instances and insert\r\n * them into a {@link module:ol/Collection~Collection} in the order you want\r\n * before creating your {@link module:ol/Map~Map} instance. Changing the order can\r\n * be of interest if the event propagation needs to be stopped at a point.\r\n * The default set of interactions, in sequence, is:\r\n * * {@link module:ol/interaction/DragRotate~DragRotate}\r\n * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}\r\n * * {@link module:ol/interaction/DragPan~DragPan}\r\n * * {@link module:ol/interaction/PinchRotate~PinchRotate}\r\n * * {@link module:ol/interaction/PinchZoom~PinchZoom}\r\n * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}\r\n * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}\r\n * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}\r\n * * {@link module:ol/interaction/DragZoom~DragZoom}\r\n *\r\n * @param {DefaultsOptions} [options] Defaults options.\r\n * @return {Collection<import(\"./Interaction.js\").default>}\r\n * A collection of interactions to be used with the {@link module:ol/Map~Map}\r\n * constructor's `interactions` option.\r\n * @api\r\n */\nexport function defaults(options) {\n  options = options ? options : {};\n\n  /** @type {Collection<import(\"./Interaction.js\").default>} */\n  const interactions = new Collection();\n  const kinetic = new Kinetic(-0.005, 0.05, 100);\n  const altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;\n  if (altShiftDragRotate) {\n    interactions.push(new DragRotate());\n  }\n  const doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;\n  if (doubleClickZoom) {\n    interactions.push(new DoubleClickZoom({\n      delta: options.zoomDelta,\n      duration: options.zoomDuration\n    }));\n  }\n  const dragPan = options.dragPan !== undefined ? options.dragPan : true;\n  if (dragPan) {\n    interactions.push(new DragPan({\n      onFocusOnly: options.onFocusOnly,\n      kinetic: kinetic\n    }));\n  }\n  const pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;\n  if (pinchRotate) {\n    interactions.push(new PinchRotate());\n  }\n  const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;\n  if (pinchZoom) {\n    interactions.push(new PinchZoom({\n      duration: options.zoomDuration\n    }));\n  }\n  const keyboard = options.keyboard !== undefined ? options.keyboard : true;\n  if (keyboard) {\n    interactions.push(new KeyboardPan());\n    interactions.push(new KeyboardZoom({\n      delta: options.zoomDelta,\n      duration: options.zoomDuration\n    }));\n  }\n  const mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;\n  if (mouseWheelZoom) {\n    interactions.push(new MouseWheelZoom({\n      onFocusOnly: options.onFocusOnly,\n      duration: options.zoomDuration\n    }));\n  }\n  const shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;\n  if (shiftDragZoom) {\n    interactions.push(new DragZoom({\n      duration: options.zoomDuration\n    }));\n  }\n  return interactions;\n}", "/**\r\n * @module ol/Map\r\n */\nimport BaseObject from './Object.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport CompositeMapRenderer from './renderer/Composite.js';\nimport EventType from './events/EventType.js';\nimport Layer from './layer/Layer.js';\nimport LayerGroup, { GroupEvent } from './layer/Group.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport RenderEventType from './render/EventType.js';\nimport TileQueue, { getTilePriority } from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport { DEVICE_PIXEL_RATIO, PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { TRUE } from './functions.js';\nimport { apply as applyTransform, create as createTransform } from './transform.js';\nimport { assert } from './asserts.js';\nimport { clone, createOrUpdateEmpty, equals as equalsExtent, getForViewAndSize, isEmpty } from './extent.js';\nimport { defaults as defaultControls } from './control/defaults.js';\nimport { defaults as defaultInteractions } from './interaction/defaults.js';\nimport { equals } from './array.js';\nimport { fromUserCoordinate, toUserCoordinate } from './proj.js';\nimport { getUid } from './util.js';\nimport { hasArea } from './size.js';\nimport { listen, unlistenByKey } from './events.js';\nimport { warn } from './console.js';\n\n/**\r\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\r\n * be used in applications.\r\n * @typedef {Object} FrameState\r\n * @property {number} pixelRatio The pixel ratio of the frame.\r\n * @property {number} time The time when rendering of the frame was requested.\r\n * @property {import(\"./View.js\").State} viewState The state of the current view.\r\n * @property {boolean} animate Animate.\r\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform CoordinateToPixelTransform.\r\n * @property {Object<string, import(\"rbush\").default<import('./render/canvas/Executor.js').DeclutterEntry>>|null} declutter\r\n * Declutter trees by declutter group.\r\n * When null, no decluttering is needed because no layers have decluttering enabled.\r\n * @property {null|import(\"./extent.js\").Extent} extent Extent (in view projection coordinates).\r\n * @property {import(\"./extent.js\").Extent} [nextExtent] Next extent during an animation series.\r\n * @property {number} index Index.\r\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray LayerStatesArray.\r\n * @property {number} layerIndex LayerIndex.\r\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.\r\n * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.\r\n * @property {import(\"./size.js\").Size} size Size.\r\n * @property {TileQueue} tileQueue TileQueue.\r\n * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.\r\n * @property {Array<number>} viewHints ViewHints.\r\n * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.\r\n * @property {string} mapId The id of the map.\r\n * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.\r\n */\n\n/**\r\n * @typedef {function(Map, FrameState): any} PostRenderFunction\r\n */\n\n/**\r\n * @typedef {Object} AtPixelOptions\r\n * @property {undefined|function(import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>): boolean} [layerFilter] Layer filter\r\n * function. The filter function will receive one argument, the\r\n * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.\r\n * Only layers which are visible and for which this function returns `true`\r\n * will be tested for features. By default, all visible layers will be tested.\r\n * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels\r\n * inside the radius around the given position will be checked for features.\r\n * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of\r\n *   +/- 1 world width. Works only if a projection is used that can be wrapped.\r\n */\n\n/**\r\n * @typedef {Object} MapOptionsInternal\r\n * @property {Collection<import(\"./control/Control.js\").default>} [controls] Controls.\r\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions] Interactions.\r\n * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.\r\n * @property {Collection<import(\"./Overlay.js\").default>} overlays Overlays.\r\n * @property {Object<string, *>} values Values.\r\n */\n\n/**\r\n * @typedef {import(\"./ObjectEventType\").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes\r\n */\n\n/***\r\n * @template Return\r\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\r\n *    import(\"./Observable\").OnSignature<MapObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\r\n *    import(\"./Observable\").OnSignature<import(\"./MapBrowserEventType\").Types, import(\"./MapBrowserEvent\").default, Return> &\r\n *    import(\"./Observable\").OnSignature<import(\"./MapEventType\").Types, import(\"./MapEvent\").default, Return> &\r\n *    import(\"./Observable\").OnSignature<import(\"./render/EventType\").MapRenderEventTypes, import(\"./render/Event\").default, Return> &\r\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|MapObjectEventTypes|\r\n *      import(\"./MapBrowserEventType\").Types|import(\"./MapEventType\").Types|\r\n *      import(\"./render/EventType\").MapRenderEventTypes, Return>} MapEventHandler\r\n */\n\n/**\r\n * Object literal with config options for the map.\r\n * @typedef {Object} MapOptions\r\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\r\n * Controls initially added to the map. If not specified,\r\n * {@link module:ol/control/defaults.defaults} is used.\r\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\r\n * physical pixels and device-independent pixels (dips) on the device.\r\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\r\n * Interactions that are initially added to the map. If not specified,\r\n * {@link module:ol/interaction/defaults.defaults} is used.\r\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\r\n * listen to keyboard events on. This determines when the `KeyboardPan` and\r\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\r\n * `document` the keyboard interactions will always trigger. If this option is\r\n * not specified, the element the library listens to keyboard events on is the\r\n * map target (i.e. the user-provided div for the map). If this is not\r\n * `document`, the target element needs to be focused for key events to be\r\n * emitted, requiring that the target element has a `tabindex` attribute.\r\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\r\n * Layers. If this is not defined, a map with no layers will be rendered. Note\r\n * that layers are rendered in the order supplied, so if you want, for example,\r\n * a vector layer to appear on top of a tile layer, it must come after the tile\r\n * layer.\r\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\r\n * simultaneously.\r\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\r\n * cursor must move to be detected as a map move event instead of a click.\r\n * Increasing this value can make it easier to click on the map.\r\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\r\n * Overlays initially added to the map. By default, no overlays are added.\r\n * @property {HTMLElement|string} [target] The container for the map, either the\r\n * element itself or the `id` of the element. If not specified at construction\r\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\r\n * rendered. If passed by element, the container can be in a secondary document.\r\n * For accessibility (focus and keyboard events for map navigation), the `target` element must have a\r\n *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the\r\n *  `tabindex` atribute must be set on the custom element's host element.\r\n * **Note:** CSS `transform` support for the target element is limited to `scale`.\r\n * @property {View|Promise<import(\"./View.js\").ViewOptions>} [view] The map's view.  No layer sources will be\r\n * fetched unless this is specified at construction time or through\r\n * {@link module:ol/Map~Map#setView}.\r\n */\n\n/**\r\n * @param {import(\"./layer/Base.js\").default} layer Layer.\r\n */\nfunction removeLayerMapProperty(layer) {\n  if (layer instanceof Layer) {\n    layer.setMapInternal(null);\n    return;\n  }\n  if (layer instanceof LayerGroup) {\n    layer.getLayers().forEach(removeLayerMapProperty);\n  }\n}\n\n/**\r\n * @param {import(\"./layer/Base.js\").default} layer Layer.\r\n * @param {Map} map Map.\r\n */\nfunction setLayerMapProperty(layer, map) {\n  if (layer instanceof Layer) {\n    layer.setMapInternal(map);\n    return;\n  }\n  if (layer instanceof LayerGroup) {\n    const layers = layer.getLayers().getArray();\n    for (let i = 0, ii = layers.length; i < ii; ++i) {\n      setLayerMapProperty(layers[i], map);\n    }\n  }\n}\n\n/**\r\n * @classdesc\r\n * The map is the core component of OpenLayers. For a map to render, a view,\r\n * one or more layers, and a target container are needed:\r\n *\r\n *     import Map from 'ol/Map.js';\r\n *     import View from 'ol/View.js';\r\n *     import TileLayer from 'ol/layer/Tile.js';\r\n *     import OSM from 'ol/source/OSM.js';\r\n *\r\n *     const map = new Map({\r\n *       view: new View({\r\n *         center: [0, 0],\r\n *         zoom: 1,\r\n *       }),\r\n *       layers: [\r\n *         new TileLayer({\r\n *           source: new OSM(),\r\n *         }),\r\n *       ],\r\n *       target: 'map',\r\n *     });\r\n *\r\n * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to\r\n * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM\r\n * element with the id `map`.\r\n *\r\n * The constructor places a viewport container (with CSS class name\r\n * `ol-viewport`) in the target element (see `getViewport()`), and then two\r\n * further elements within the viewport: one with CSS class name\r\n * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with\r\n * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`\r\n * option of {@link module:ol/Overlay~Overlay} for the difference). The map\r\n * itself is placed in a further element within the viewport.\r\n *\r\n * Layers are stored as a {@link module:ol/Collection~Collection} in\r\n * layerGroups. A top-level group is provided by the library. This is what is\r\n * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the\r\n * options are added to this group, and `addLayer` and `removeLayer` change the\r\n * layer collection in the group. `getLayers` is a convenience function for\r\n * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}\r\n * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the\r\n * options or added with `addLayer` can be groups, which can contain further\r\n * groups, and so on.\r\n *\r\n * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\r\n * @fires import(\"./MapEvent.js\").MapEvent\r\n * @fires import(\"./render/Event.js\").default#precompose\r\n * @fires import(\"./render/Event.js\").default#postcompose\r\n * @fires import(\"./render/Event.js\").default#rendercomplete\r\n * @api\r\n */\nclass Map extends BaseObject {\n  /**\r\n   * @param {MapOptions} [options] Map options.\r\n   */\n  constructor(options) {\n    super();\n    options = options || {};\n\n    /***\r\n     * @type {MapEventHandler<import(\"./events\").EventsKey>}\r\n     */\n    this.on;\n\n    /***\r\n     * @type {MapEventHandler<import(\"./events\").EventsKey>}\r\n     */\n    this.once;\n\n    /***\r\n     * @type {MapEventHandler<void>}\r\n     */\n    this.un;\n    const optionsInternal = createOptionsInternal(options);\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.renderComplete_ = false;\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.loaded_ = true;\n\n    /** @private */\n    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);\n\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : DEVICE_PIXEL_RATIO;\n\n    /**\r\n     * @private\r\n     * @type {ReturnType<typeof setTimeout>}\r\n     */\n    this.postRenderTimeoutHandle_;\n\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\n    this.animationDelayKey_;\n\n    /**\r\n     * @private\r\n     */\n    this.animationDelay_ = this.animationDelay_.bind(this);\n\n    /**\r\n     * @private\r\n     * @type {import(\"./transform.js\").Transform}\r\n     */\n    this.coordinateToPixelTransform_ = createTransform();\n\n    /**\r\n     * @private\r\n     * @type {import(\"./transform.js\").Transform}\r\n     */\n    this.pixelToCoordinateTransform_ = createTransform();\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.frameIndex_ = 0;\n\n    /**\r\n     * @private\r\n     * @type {?FrameState}\r\n     */\n    this.frameState_ = null;\n\n    /**\r\n     * The extent at the previous 'moveend' event.\r\n     * @private\r\n     * @type {import(\"./extent.js\").Extent}\r\n     */\n    this.previousExtent_ = null;\n\n    /**\r\n     * @private\r\n     * @type {?import(\"./events.js\").EventsKey}\r\n     */\n    this.viewPropertyListenerKey_ = null;\n\n    /**\r\n     * @private\r\n     * @type {?import(\"./events.js\").EventsKey}\r\n     */\n    this.viewChangeListenerKey_ = null;\n\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"./events.js\").EventsKey>}\r\n     */\n    this.layerGroupPropertyListenerKeys_ = null;\n\n    /**\r\n     * @private\r\n     * @type {!HTMLElement}\r\n     */\n    this.viewport_ = document.createElement('div');\n    this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');\n    this.viewport_.style.position = 'relative';\n    this.viewport_.style.overflow = 'hidden';\n    this.viewport_.style.width = '100%';\n    this.viewport_.style.height = '100%';\n\n    /**\r\n     * @private\r\n     * @type {!HTMLElement}\r\n     */\n    this.overlayContainer_ = document.createElement('div');\n    this.overlayContainer_.style.position = 'absolute';\n    this.overlayContainer_.style.zIndex = '0';\n    this.overlayContainer_.style.width = '100%';\n    this.overlayContainer_.style.height = '100%';\n    this.overlayContainer_.style.pointerEvents = 'none';\n    this.overlayContainer_.className = 'ol-overlaycontainer';\n    this.viewport_.appendChild(this.overlayContainer_);\n\n    /**\r\n     * @private\r\n     * @type {!HTMLElement}\r\n     */\n    this.overlayContainerStopEvent_ = document.createElement('div');\n    this.overlayContainerStopEvent_.style.position = 'absolute';\n    this.overlayContainerStopEvent_.style.zIndex = '0';\n    this.overlayContainerStopEvent_.style.width = '100%';\n    this.overlayContainerStopEvent_.style.height = '100%';\n    this.overlayContainerStopEvent_.style.pointerEvents = 'none';\n    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n    this.viewport_.appendChild(this.overlayContainerStopEvent_);\n\n    /**\r\n     * @private\r\n     * @type {MapBrowserEventHandler}\r\n     */\n    this.mapBrowserEventHandler_ = null;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.moveTolerance_ = options.moveTolerance;\n\n    /**\r\n     * @private\r\n     * @type {HTMLElement|Document}\r\n     */\n    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"./events.js\").EventsKey>}\r\n     */\n    this.targetChangeHandlerKeys_ = null;\n\n    /**\r\n     * @private\r\n     * @type {HTMLElement|null}\r\n     */\n    this.targetElement_ = null;\n\n    /**\r\n     * @private\r\n     * @type {ResizeObserver}\r\n     */\n    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());\n\n    /**\r\n     * @type {Collection<import(\"./control/Control.js\").default>}\r\n     * @protected\r\n     */\n    this.controls = optionsInternal.controls || defaultControls();\n\n    /**\r\n     * @type {Collection<import(\"./interaction/Interaction.js\").default>}\r\n     * @protected\r\n     */\n    this.interactions = optionsInternal.interactions || defaultInteractions({\n      onFocusOnly: true\n    });\n\n    /**\r\n     * @type {Collection<import(\"./Overlay.js\").default>}\r\n     * @private\r\n     */\n    this.overlays_ = optionsInternal.overlays;\n\n    /**\r\n     * A lookup of overlays by id.\r\n     * @private\r\n     * @type {Object<string, import(\"./Overlay.js\").default>}\r\n     */\n    this.overlayIdIndex_ = {};\n\n    /**\r\n     * @type {import(\"./renderer/Map.js\").default|null}\r\n     * @private\r\n     */\n    this.renderer_ = null;\n\n    /**\r\n     * @private\r\n     * @type {!Array<PostRenderFunction>}\r\n     */\n    this.postRenderFunctions_ = [];\n\n    /**\r\n     * @private\r\n     * @type {TileQueue}\r\n     */\n    this.tileQueue_ = new TileQueue(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));\n    this.addChangeListener(MapProperty.LAYERGROUP, this.handleLayerGroupChanged_);\n    this.addChangeListener(MapProperty.VIEW, this.handleViewChanged_);\n    this.addChangeListener(MapProperty.SIZE, this.handleSizeChanged_);\n    this.addChangeListener(MapProperty.TARGET, this.handleTargetChanged_);\n\n    // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n    this.setProperties(optionsInternal.values);\n    const map = this;\n    if (options.view && !(options.view instanceof View)) {\n      options.view.then(function (viewOptions) {\n        map.setView(new View(viewOptions));\n      });\n    }\n    this.controls.addEventListener(CollectionEventType.ADD,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./control/Control.js\").default>} event CollectionEvent\r\n     */\n    event => {\n      event.element.setMap(this);\n    });\n    this.controls.addEventListener(CollectionEventType.REMOVE,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./control/Control.js\").default>} event CollectionEvent.\r\n     */\n    event => {\n      event.element.setMap(null);\n    });\n    this.interactions.addEventListener(CollectionEventType.ADD,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./interaction/Interaction.js\").default>} event CollectionEvent.\r\n     */\n    event => {\n      event.element.setMap(this);\n    });\n    this.interactions.addEventListener(CollectionEventType.REMOVE,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./interaction/Interaction.js\").default>} event CollectionEvent.\r\n     */\n    event => {\n      event.element.setMap(null);\n    });\n    this.overlays_.addEventListener(CollectionEventType.ADD,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./Overlay.js\").default>} event CollectionEvent.\r\n     */\n    event => {\n      this.addOverlayInternal_(event.element);\n    });\n    this.overlays_.addEventListener(CollectionEventType.REMOVE,\n    /**\r\n     * @param {import(\"./Collection.js\").CollectionEvent<import(\"./Overlay.js\").default>} event CollectionEvent.\r\n     */\n    event => {\n      const id = event.element.getId();\n      if (id !== undefined) {\n        delete this.overlayIdIndex_[id.toString()];\n      }\n      event.element.setMap(null);\n    });\n    this.controls.forEach(\n    /**\r\n     * @param {import(\"./control/Control.js\").default} control Control.\r\n     */\n    control => {\n      control.setMap(this);\n    });\n    this.interactions.forEach(\n    /**\r\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\r\n     */\n    interaction => {\n      interaction.setMap(this);\n    });\n    this.overlays_.forEach(this.addOverlayInternal_.bind(this));\n  }\n\n  /**\r\n   * Add the given control to the map.\r\n   * @param {import(\"./control/Control.js\").default} control Control.\r\n   * @api\r\n   */\n  addControl(control) {\n    this.getControls().push(control);\n  }\n\n  /**\r\n   * Add the given interaction to the map. If you want to add an interaction\r\n   * at another point of the collection use `getInteractions()` and the methods\r\n   * available on {@link module:ol/Collection~Collection}. This can be used to\r\n   * stop the event propagation from the handleEvent function. The interactions\r\n   * get to handle the events in the reverse order of this collection.\r\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\r\n   * @api\r\n   */\n  addInteraction(interaction) {\n    this.getInteractions().push(interaction);\n  }\n\n  /**\r\n   * Adds the given layer to the top of this map. If you want to add a layer\r\n   * elsewhere in the stack, use `getLayers()` and the methods available on\r\n   * {@link module:ol/Collection~Collection}.\r\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\r\n   * @api\r\n   */\n  addLayer(layer) {\n    const layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  }\n\n  /**\r\n   * @param {import(\"./layer/Group.js\").GroupEvent} event The layer add event.\r\n   * @private\r\n   */\n  handleLayerAdd_(event) {\n    setLayerMapProperty(event.layer, this);\n  }\n\n  /**\r\n   * Add the given overlay to the map.\r\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\r\n   * @api\r\n   */\n  addOverlay(overlay) {\n    this.getOverlays().push(overlay);\n  }\n\n  /**\r\n   * This deals with map's overlay collection changes.\r\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\r\n   * @private\r\n   */\n  addOverlayInternal_(overlay) {\n    const id = overlay.getId();\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n    overlay.setMap(this);\n  }\n\n  /**\r\n   *\r\n   * Clean up.\r\n   * @override\r\n   */\n  disposeInternal() {\n    this.controls.clear();\n    this.interactions.clear();\n    this.overlays_.clear();\n    this.resizeObserver_.disconnect();\n    this.setTarget(null);\n    super.disposeInternal();\n  }\n\n  /**\r\n   * Detect features that intersect a pixel on the viewport, and execute a\r\n   * callback with each intersecting feature. Layers included in the detection can\r\n   * be configured through the `layerFilter` option in `options`.\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\r\n   * @param {function(import(\"./Feature.js\").FeatureLike, import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>, import(\"./geom/SimpleGeometry.js\").default): T} callback Feature callback. The callback will be\r\n   *     called with two arguments. The first argument is one\r\n   *     {@link module:ol/Feature~Feature feature} or\r\n   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is\r\n   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\r\n   *     unmanaged layers. To stop detection, callback functions can return a\r\n   *     truthy value.\r\n   * @param {AtPixelOptions} [options] Optional options.\r\n   * @return {T|undefined} Callback result, i.e. the return value of last\r\n   * callback execution, or the first truthy callback return value.\r\n   * @template T\r\n   * @api\r\n   */\n  forEachFeatureAtPixel(pixel, callback, options) {\n    if (!this.frameState_ || !this.renderer_) {\n      return;\n    }\n    const coordinate = this.getCoordinateFromPixelInternal(pixel);\n    options = options !== undefined ? options : {};\n    const hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;\n    const layerFilter = options.layerFilter !== undefined ? options.layerFilter : TRUE;\n    const checkWrapped = options.checkWrapped !== false;\n    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);\n  }\n\n  /**\r\n   * Get all features that intersect a pixel on the viewport.\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\r\n   * @param {AtPixelOptions} [options] Optional options.\r\n   * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\r\n   * an empty array if none were found.\r\n   * @api\r\n   */\n  getFeaturesAtPixel(pixel, options) {\n    const features = [];\n    this.forEachFeatureAtPixel(pixel, function (feature) {\n      features.push(feature);\n    }, options);\n    return features;\n  }\n\n  /**\r\n   * Get all layers from all layer groups.\r\n   * @return {Array<import(\"./layer/Layer.js\").default>} Layers.\r\n   * @api\r\n   */\n  getAllLayers() {\n    const layers = [];\n    function addLayersFrom(layerGroup) {\n      layerGroup.forEach(function (layer) {\n        if (layer instanceof LayerGroup) {\n          addLayersFrom(layer.getLayers());\n        } else {\n          layers.push(layer);\n        }\n      });\n    }\n    addLayersFrom(this.getLayers());\n    return layers;\n  }\n\n  /**\r\n   * Detect if features intersect a pixel on the viewport. Layers included in the\r\n   * detection can be configured through the `layerFilter` option.\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\r\n   * @param {AtPixelOptions} [options] Optional options.\r\n   * @return {boolean} Is there a feature at the given pixel?\r\n   * @api\r\n   */\n  hasFeatureAtPixel(pixel, options) {\n    if (!this.frameState_ || !this.renderer_) {\n      return false;\n    }\n    const coordinate = this.getCoordinateFromPixelInternal(pixel);\n    options = options !== undefined ? options : {};\n    const layerFilter = options.layerFilter !== undefined ? options.layerFilter : TRUE;\n    const hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;\n    const checkWrapped = options.checkWrapped !== false;\n    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);\n  }\n\n  /**\r\n   * Returns the coordinate in user projection for a browser event.\r\n   * @param {MouseEvent} event Event.\r\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\r\n   * @api\r\n   */\n  getEventCoordinate(event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  }\n\n  /**\r\n   * Returns the coordinate in view projection for a browser event.\r\n   * @param {MouseEvent} event Event.\r\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\r\n   */\n  getEventCoordinateInternal(event) {\n    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));\n  }\n\n  /**\r\n   * Returns the map pixel position for a browser event relative to the viewport.\r\n   * @param {UIEvent|{clientX: number, clientY: number}} event Event.\r\n   * @return {import(\"./pixel.js\").Pixel} Pixel.\r\n   * @api\r\n   */\n  getEventPixel(event) {\n    const viewport = this.viewport_;\n    const viewportPosition = viewport.getBoundingClientRect();\n    const viewportSize = this.getSize();\n    const scaleX = viewportPosition.width / viewportSize[0];\n    const scaleY = viewportPosition.height / viewportSize[1];\n    const eventPosition =\n    //FIXME Are we really calling this with a TouchEvent anywhere?\n    'changedTouches' in event ? /** @type {TouchEvent} */event.changedTouches[0] : (/** @type {MouseEvent} */event);\n    return [(eventPosition.clientX - viewportPosition.left) / scaleX, (eventPosition.clientY - viewportPosition.top) / scaleY];\n  }\n\n  /**\r\n   * Get the target in which this map is rendered.\r\n   * Note that this returns what is entered as an option or in setTarget:\r\n   * if that was an element, it returns an element; if a string, it returns that.\r\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\r\n   *     map is rendered in.\r\n   * @observable\r\n   * @api\r\n   */\n  getTarget() {\n    return /** @type {HTMLElement|string|undefined} */this.get(MapProperty.TARGET);\n  }\n\n  /**\r\n   * Get the DOM element into which this map is rendered. In contrast to\r\n   * `getTarget` this method always return an `Element`, or `null` if the\r\n   * map has no target.\r\n   * @return {HTMLElement} The element that the map is rendered in.\r\n   * @api\r\n   */\n  getTargetElement() {\n    return this.targetElement_;\n  }\n\n  /**\r\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\r\n   * user projection.\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\r\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\r\n   * @api\r\n   */\n  getCoordinateFromPixel(pixel) {\n    return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());\n  }\n\n  /**\r\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\r\n   * map view projection.\r\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\r\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\r\n   */\n  getCoordinateFromPixelInternal(pixel) {\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    }\n    return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n  }\n\n  /**\r\n   * Get the map controls. Modifying this collection changes the controls\r\n   * associated with the map.\r\n   * @return {Collection<import(\"./control/Control.js\").default>} Controls.\r\n   * @api\r\n   */\n  getControls() {\n    return this.controls;\n  }\n\n  /**\r\n   * Get the map overlays. Modifying this collection changes the overlays\r\n   * associated with the map.\r\n   * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\r\n   * @api\r\n   */\n  getOverlays() {\n    return this.overlays_;\n  }\n\n  /**\r\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\r\n   * Note that the index treats string and numeric identifiers as the same. So\r\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\r\n   * @param {string|number} id Overlay identifier.\r\n   * @return {import(\"./Overlay.js\").default|null} Overlay.\r\n   * @api\r\n   */\n  getOverlayById(id) {\n    const overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  }\n\n  /**\r\n   * Get the map interactions. Modifying this collection changes the interactions\r\n   * associated with the map.\r\n   *\r\n   * Interactions are used for e.g. pan, zoom and rotate.\r\n   * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\r\n   * @api\r\n   */\n  getInteractions() {\n    return this.interactions;\n  }\n\n  /**\r\n   * Get the layergroup associated with this map.\r\n   * @return {LayerGroup} A layer group containing the layers in this map.\r\n   * @observable\r\n   * @api\r\n   */\n  getLayerGroup() {\n    return /** @type {LayerGroup} */this.get(MapProperty.LAYERGROUP);\n  }\n\n  /**\r\n   * Clear any existing layers and add layers to the map.\r\n   * @param {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>} layers The layers to be added to the map.\r\n   * @api\r\n   */\n  setLayers(layers) {\n    const group = this.getLayerGroup();\n    if (layers instanceof Collection) {\n      group.setLayers(layers);\n      return;\n    }\n    const collection = group.getLayers();\n    collection.clear();\n    collection.extend(layers);\n  }\n\n  /**\r\n   * Get the collection of layers associated with this map.\r\n   * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\r\n   * @api\r\n   */\n  getLayers() {\n    const layers = this.getLayerGroup().getLayers();\n    return layers;\n  }\n\n  /**\r\n   * @return {boolean} Layers have sources that are still loading.\r\n   */\n  getLoadingOrNotReady() {\n    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      const state = layerStatesArray[i];\n      if (!state.visible) {\n        continue;\n      }\n      const renderer = state.layer.getRenderer();\n      if (renderer && !renderer.ready) {\n        return true;\n      }\n      const source = state.layer.getSource();\n      if (source && source.loading) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * Get the pixel for a coordinate.  This takes a coordinate in the user\r\n   * projection and returns the corresponding pixel.\r\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\r\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\r\n   * @api\r\n   */\n  getPixelFromCoordinate(coordinate) {\n    const viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());\n    return this.getPixelFromCoordinateInternal(viewCoordinate);\n  }\n\n  /**\r\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\r\n   * projection and returns the corresponding pixel.\r\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\r\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\r\n   */\n  getPixelFromCoordinateInternal(coordinate) {\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    }\n    return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n  }\n\n  /**\r\n   * Get the map renderer.\r\n   * @return {import(\"./renderer/Map.js\").default|null} Renderer\r\n   */\n  getRenderer() {\n    return this.renderer_;\n  }\n\n  /**\r\n   * Get the size of this map.\r\n   * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\r\n   * @observable\r\n   * @api\r\n   */\n  getSize() {\n    return /** @type {import(\"./size.js\").Size|undefined} */this.get(MapProperty.SIZE);\n  }\n\n  /**\r\n   * Get the view associated with this map. A view manages properties such as\r\n   * center and resolution.\r\n   * @return {View} The view that controls this map.\r\n   * @observable\r\n   * @api\r\n   */\n  getView() {\n    return /** @type {View} */this.get(MapProperty.VIEW);\n  }\n\n  /**\r\n   * Get the element that serves as the map viewport.\r\n   * @return {HTMLElement} Viewport.\r\n   * @api\r\n   */\n  getViewport() {\n    return this.viewport_;\n  }\n\n  /**\r\n   * Get the element that serves as the container for overlays.  Elements added to\r\n   * this container will let mousedown and touchstart events through to the map,\r\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\r\n   * events.\r\n   * @return {!HTMLElement} The map's overlay container.\r\n   */\n  getOverlayContainer() {\n    return this.overlayContainer_;\n  }\n\n  /**\r\n   * Get the element that serves as a container for overlays that don't allow\r\n   * event propagation. Elements added to this container won't let mousedown and\r\n   * touchstart events through to the map, so clicks and gestures on an overlay\r\n   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\r\n   * @return {!HTMLElement} The map's overlay container that stops events.\r\n   */\n  getOverlayContainerStopEvent() {\n    return this.overlayContainerStopEvent_;\n  }\n\n  /**\r\n   * @return {!Document} The document where the map is displayed.\r\n   */\n  getOwnerDocument() {\n    const targetElement = this.getTargetElement();\n    return targetElement ? targetElement.ownerDocument : document;\n  }\n\n  /**\r\n   * @param {import(\"./Tile.js\").default} tile Tile.\r\n   * @param {string} tileSourceKey Tile source key.\r\n   * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\r\n   * @param {number} tileResolution Tile resolution.\r\n   * @return {number} Tile priority.\r\n   */\n  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {\n    return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);\n  }\n\n  /**\r\n   * @param {UIEvent} browserEvent Browser event.\r\n   * @param {string} [type] Type.\r\n   */\n  handleBrowserEvent(browserEvent, type) {\n    type = type || browserEvent.type;\n    const mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  }\n\n  /**\r\n   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\r\n   */\n  handleMapBrowserEvent(mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n    const originalEvent = /** @type {PointerEvent} */\n    mapBrowserEvent.originalEvent;\n    const eventType = originalEvent.type;\n    if (eventType === PointerEventType.POINTERDOWN || eventType === EventType.WHEEL || eventType === EventType.KEYDOWN) {\n      const doc = this.getOwnerDocument();\n      const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;\n      const target = /** @type {Node} */originalEvent.target;\n      const currentDoc = rootNode instanceof ShadowRoot ? rootNode.host === target ? rootNode.host.ownerDocument : rootNode : rootNode === doc ? doc.documentElement : rootNode;\n      if (\n      // Abort if the target is a child of the container for elements whose events are not meant\n      // to be handled by map interactions.\n      this.overlayContainerStopEvent_.contains(target) ||\n      // Abort if the event target is a child of the container that is no longer in the page.\n      // It's possible for the target to no longer be in the page if it has been removed in an\n      // event listener, this might happen in a Control that recreates it's content based on\n      // user interaction either manually or via a render in something like https://reactjs.org/\n      !currentDoc.contains(target)) {\n        return;\n      }\n    }\n    mapBrowserEvent.frameState = this.frameState_;\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      const interactionsArray = this.getInteractions().getArray().slice();\n      for (let i = interactionsArray.length - 1; i >= 0; i--) {\n        const interaction = interactionsArray[i];\n        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {\n          continue;\n        }\n        const cont = interaction.handleEvent(mapBrowserEvent);\n        if (!cont || mapBrowserEvent.propagationStopped) {\n          break;\n        }\n      }\n    }\n  }\n\n  /**\r\n   * @protected\r\n   */\n  handlePostRender() {\n    const frameState = this.frameState_;\n\n    // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n    const tileQueue = this.tileQueue_;\n    if (!tileQueue.isEmpty()) {\n      let maxTotalLoading = this.maxTilesLoading_;\n      let maxNewLoads = maxTotalLoading;\n      if (frameState) {\n        const hints = frameState.viewHints;\n        if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {\n          const lowOnFrameBudget = Date.now() - frameState.time > 8;\n          maxTotalLoading = lowOnFrameBudget ? 0 : 8;\n          maxNewLoads = lowOnFrameBudget ? 0 : 2;\n        }\n      }\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n    if (frameState && this.renderer_ && !frameState.animate) {\n      if (this.renderComplete_) {\n        if (this.hasListener(RenderEventType.RENDERCOMPLETE)) {\n          this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n        }\n        if (this.loaded_ === false) {\n          this.loaded_ = true;\n          this.dispatchEvent(new MapEvent(MapEventType.LOADEND, this, frameState));\n        }\n      } else if (this.loaded_ === true) {\n        this.loaded_ = false;\n        this.dispatchEvent(new MapEvent(MapEventType.LOADSTART, this, frameState));\n      }\n    }\n    const postRenderFunctions = this.postRenderFunctions_;\n    if (frameState) {\n      for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n        postRenderFunctions[i](this, frameState);\n      }\n    }\n    postRenderFunctions.length = 0;\n  }\n\n  /**\r\n   * @private\r\n   */\n  handleSizeChanged_() {\n    if (this.getView() && !this.getView().getAnimating()) {\n      this.getView().resolveConstraints(0);\n    }\n    this.render();\n  }\n\n  /**\r\n   * @private\r\n   */\n  handleTargetChanged_() {\n    if (this.mapBrowserEventHandler_) {\n      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this.targetChangeHandlerKeys_[i]);\n      }\n      this.targetChangeHandlerKeys_ = null;\n      this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);\n      this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);\n      this.mapBrowserEventHandler_.dispose();\n      this.mapBrowserEventHandler_ = null;\n      this.viewport_.remove();\n    }\n    if (this.targetElement_) {\n      this.resizeObserver_.unobserve(this.targetElement_);\n      const rootNode = this.targetElement_.getRootNode();\n      if (rootNode instanceof ShadowRoot) {\n        this.resizeObserver_.unobserve(rootNode.host);\n      }\n      this.setSize(undefined);\n    }\n\n    // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n\n    const target = this.getTarget();\n    const targetElement = typeof target === 'string' ? document.getElementById(target) : target;\n    this.targetElement_ = targetElement;\n    if (!targetElement) {\n      if (this.renderer_) {\n        clearTimeout(this.postRenderTimeoutHandle_);\n        this.postRenderTimeoutHandle_ = undefined;\n        this.postRenderFunctions_.length = 0;\n        this.renderer_.dispose();\n        this.renderer_ = null;\n      }\n      if (this.animationDelayKey_) {\n        cancelAnimationFrame(this.animationDelayKey_);\n        this.animationDelayKey_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n      if (!this.renderer_) {\n        this.renderer_ = new CompositeMapRenderer(this);\n      }\n      this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);\n      for (const key in MapBrowserEventType) {\n        this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));\n      }\n      this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);\n      this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? {\n        passive: false\n      } : false);\n      let keyboardEventTarget;\n      if (!this.keyboardEventTarget_) {\n        // check if map target is in shadowDOM, if yes use host element as target\n        const targetRoot = targetElement.getRootNode();\n        const targetCandidate = targetRoot instanceof ShadowRoot ? targetRoot.host : targetElement;\n        keyboardEventTarget = targetCandidate;\n      } else {\n        keyboardEventTarget = this.keyboardEventTarget_;\n      }\n      this.targetChangeHandlerKeys_ = [listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)];\n      const rootNode = targetElement.getRootNode();\n      if (rootNode instanceof ShadowRoot) {\n        this.resizeObserver_.observe(rootNode.host);\n      }\n      this.resizeObserver_.observe(targetElement);\n    }\n    this.updateSize();\n    // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  }\n\n  /**\r\n   * @private\r\n   */\n  handleTileChange_() {\n    this.render();\n  }\n\n  /**\r\n   * @private\r\n   */\n  handleViewPropertyChanged_() {\n    this.render();\n  }\n\n  /**\r\n   * @private\r\n   */\n  handleViewChanged_() {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n    const view = this.getView();\n    if (view) {\n      this.updateViewportSize_(this.getSize());\n      this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n      view.resolveConstraints(0);\n    }\n    this.render();\n  }\n\n  /**\r\n   * @private\r\n   */\n  handleLayerGroupChanged_() {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n    const layerGroup = this.getLayerGroup();\n    if (layerGroup) {\n      this.handleLayerAdd_(new GroupEvent('addlayer', layerGroup));\n      this.layerGroupPropertyListenerKeys_ = [listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(layerGroup, EventType.CHANGE, this.render, this), listen(layerGroup, 'addlayer', this.handleLayerAdd_, this), listen(layerGroup, 'removelayer', this.handleLayerRemove_, this)];\n    }\n    this.render();\n  }\n\n  /**\r\n   * @return {boolean} Is rendered.\r\n   */\n  isRendered() {\n    return !!this.frameState_;\n  }\n\n  /**\r\n   * @private\r\n   */\n  animationDelay_() {\n    this.animationDelayKey_ = undefined;\n    this.renderFrame_(Date.now());\n  }\n\n  /**\r\n   * Requests an immediate render in a synchronous manner.\r\n   * @api\r\n   */\n  renderSync() {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n    this.animationDelay_();\n  }\n\n  /**\r\n   * Redraws all text after new fonts have loaded\r\n   */\n  redrawText() {\n    const layerStates = this.getLayerGroup().getLayerStatesArray();\n    for (let i = 0, ii = layerStates.length; i < ii; ++i) {\n      const layer = layerStates[i].layer;\n      if (layer.hasRenderer()) {\n        layer.getRenderer().handleFontsChanged();\n      }\n    }\n  }\n\n  /**\r\n   * Request a map rendering (at the next animation frame).\r\n   * @api\r\n   */\n  render() {\n    if (this.renderer_ && this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  }\n\n  /**\r\n   * Remove the given control from the map.\r\n   * @param {import(\"./control/Control.js\").default} control Control.\r\n   * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\r\n   *     if the control was not found).\r\n   * @api\r\n   */\n  removeControl(control) {\n    return this.getControls().remove(control);\n  }\n\n  /**\r\n   * Remove the given interaction from the map.\r\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\r\n   * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\r\n   *     undefined if the interaction was not found).\r\n   * @api\r\n   */\n  removeInteraction(interaction) {\n    return this.getInteractions().remove(interaction);\n  }\n\n  /**\r\n   * Removes the given layer from the map.\r\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\r\n   * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\r\n   *     layer was not found).\r\n   * @api\r\n   */\n  removeLayer(layer) {\n    const layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  }\n\n  /**\r\n   * @param {import(\"./layer/Group.js\").GroupEvent} event The layer remove event.\r\n   * @private\r\n   */\n  handleLayerRemove_(event) {\n    removeLayerMapProperty(event.layer);\n  }\n\n  /**\r\n   * Remove the given overlay from the map.\r\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\r\n   * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\r\n   *     if the overlay was not found).\r\n   * @api\r\n   */\n  removeOverlay(overlay) {\n    return this.getOverlays().remove(overlay);\n  }\n\n  /**\r\n   * @param {number} time Time.\r\n   * @private\r\n   */\n  renderFrame_(time) {\n    const size = this.getSize();\n    const view = this.getView();\n    const previousFrameState = this.frameState_;\n    /** @type {?FrameState} */\n    let frameState = null;\n    if (size !== undefined && hasArea(size) && view && view.isDef()) {\n      const viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n      const viewState = view.getState();\n      frameState = {\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        declutter: null,\n        extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),\n        index: this.frameIndex_++,\n        layerIndex: 0,\n        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {},\n        mapId: getUid(this),\n        renderTargets: {}\n      };\n      if (viewState.nextCenter && viewState.nextResolution) {\n        const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;\n        frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);\n      }\n    }\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n      if (previousFrameState) {\n        const moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equalsExtent(frameState.extent, this.previousExtent_);\n        if (moveStart) {\n          this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n      const idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equalsExtent(frameState.extent, this.previousExtent_);\n      if (idle) {\n        this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n        clone(frameState.extent, this.previousExtent_);\n      }\n    }\n    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n    this.renderComplete_ = (this.hasListener(MapEventType.LOADSTART) || this.hasListener(MapEventType.LOADEND) || this.hasListener(RenderEventType.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady();\n    if (!this.postRenderTimeoutHandle_) {\n      this.postRenderTimeoutHandle_ = setTimeout(() => {\n        this.postRenderTimeoutHandle_ = undefined;\n        this.handlePostRender();\n      }, 0);\n    }\n  }\n\n  /**\r\n   * Sets the layergroup of this map.\r\n   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\r\n   * @observable\r\n   * @api\r\n   */\n  setLayerGroup(layerGroup) {\n    const oldLayerGroup = this.getLayerGroup();\n    if (oldLayerGroup) {\n      this.handleLayerRemove_(new GroupEvent('removelayer', oldLayerGroup));\n    }\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  }\n\n  /**\r\n   * Set the size of this map.\r\n   * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\r\n   * @observable\r\n   * @api\r\n   */\n  setSize(size) {\n    this.set(MapProperty.SIZE, size);\n  }\n\n  /**\r\n   * Set the target element to render this map into.\r\n   * For accessibility (focus and keyboard events for map navigation), the `target` element must have a\r\n   *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the\r\n   *  `tabindex` atribute must be set on the custom element's host element.\r\n   * @param {HTMLElement|string} [target] The Element or id of the Element\r\n   *     that the map is rendered in.\r\n   * @observable\r\n   * @api\r\n   */\n  setTarget(target) {\n    this.set(MapProperty.TARGET, target);\n  }\n\n  /**\r\n   * Set the view for this map.\r\n   * @param {View|Promise<import(\"./View.js\").ViewOptions>} view The view that controls this map.\r\n   * It is also possible to pass a promise that resolves to options for constructing a view.  This\r\n   * alternative allows view properties to be resolved by sources or other components that load\r\n   * view-related metadata.\r\n   * @observable\r\n   * @api\r\n   */\n  setView(view) {\n    if (!view || view instanceof View) {\n      this.set(MapProperty.VIEW, view);\n      return;\n    }\n    this.set(MapProperty.VIEW, new View());\n    const map = this;\n    view.then(function (viewOptions) {\n      map.setView(new View(viewOptions));\n    });\n  }\n\n  /**\r\n   * Force a recalculation of the map viewport size.  This should be called when\r\n   * third-party code changes the size of the map viewport.\r\n   * @api\r\n   */\n  updateSize() {\n    const targetElement = this.getTargetElement();\n    let size = undefined;\n    if (targetElement) {\n      const computedStyle = getComputedStyle(targetElement);\n      const width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);\n      const height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);\n      if (!isNaN(width) && !isNaN(height)) {\n        size = [Math.max(0, width), Math.max(0, height)];\n        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {\n          warn(\"No map visible because the map container's width or height are 0.\");\n        }\n      }\n    }\n    const oldSize = this.getSize();\n    if (size && (!oldSize || !equals(size, oldSize))) {\n      this.setSize(size);\n      this.updateViewportSize_(size);\n    }\n  }\n\n  /**\r\n   * Recomputes the viewport size and save it on the view object (if any)\r\n   * @param {import(\"./size.js\").Size|undefined} size The size.\r\n   * @private\r\n   */\n  updateViewportSize_(size) {\n    const view = this.getView();\n    if (view) {\n      view.setViewportSize(size);\n    }\n  }\n}\n\n/**\r\n * @param {MapOptions} options Map options.\r\n * @return {MapOptionsInternal} Internal map options.\r\n */\nfunction createOptionsInternal(options) {\n  /**\r\n   * @type {HTMLElement|Document}\r\n   */\n  let keyboardEventTarget = null;\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;\n  }\n\n  /**\r\n   * @type {Object<string, *>}\r\n   */\n  const values = {};\n  const layerGroup = options.layers && typeof (/** @type {?} */options.layers.getLayers) === 'function' ? (/** @type {LayerGroup} */options.layers) : new LayerGroup({\n    layers: (/** @type {Collection<import(\"./layer/Base.js\").default>|Array<import(\"./layer/Base.js\").default>} */\n    options.layers)\n  });\n  values[MapProperty.LAYERGROUP] = layerGroup;\n  values[MapProperty.TARGET] = options.target;\n  values[MapProperty.VIEW] = options.view instanceof View ? options.view : new View();\n\n  /** @type {Collection<import(\"./control/Control.js\").default>} */\n  let controls;\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(typeof (/** @type {?} */options.controls.getArray) === 'function', 'Expected `controls` to be an array or an `ol/Collection.js`');\n      controls = options.controls;\n    }\n  }\n\n  /** @type {Collection<import(\"./interaction/Interaction\").default>} */\n  let interactions;\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(typeof (/** @type {?} */options.interactions.getArray) === 'function', 'Expected `interactions` to be an array or an `ol/Collection.js`');\n      interactions = options.interactions;\n    }\n  }\n\n  /** @type {Collection<import(\"./Overlay.js\").default>} */\n  let overlays;\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(typeof (/** @type {?} */options.overlays.getArray) === 'function', 'Expected `overlays` to be an array or an `ol/Collection.js`');\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values\n  };\n}\nexport default Map;"],
  "mappings": "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",
  "names": ["callback", "Event_default", "EventType_default", "EventType_default", "EventType_default", "newEvent", "centroid", "map", "defaults", "defaults", "EventType_default", "equals", "Map_default"]
}
